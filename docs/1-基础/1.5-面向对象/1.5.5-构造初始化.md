# 拷贝初始化和直接初始化区别

| 类型       | 形式                 | 说明                                                         |
| ---------- | -------------------- | ------------------------------------------------------------ |
| 直接初始化 | ClassTest ct1(“ab”)  | 它不需要调用复制构造函数，直接调用构造函数ClassTest(constchar *pc)，<br/>所以当复制构造函数变为私有时，它还是能直接执行的。 |
|            | ClassTest ct4（ct1） | 因为 ct1 本来已经存在，直接调用复制构造函数，生成对象 ct3 的副本对象 ct4。<br/>所以当复制构造函数变为私有时，该语句不能编译通过。 |
| 复制初始化 | ClassTest ct2 = “ab” | 它首先调用构造函数 ClassTest(const char* pc) 函数创建一个临时对象，<br> 然后调用复制构造函数，把这个临时对象作为参数，构造对象ct2；所以当复制构造函数变为私有时，该语句不能编译通过。 |
|            | ClassTest ct3 = ct1; | 因为 ct1 本来已经存在，所以不需要调用相关的构造函数，而直接调用复制构造函数<br/>把它值复制给对象 ct3；所以当复制构造函数变为私有时，该语句不能编译通过。 |

# 初始化和赋值的区别

## 调用的函数不同

初始化：调用构造函数。

赋值：调用复制构造函数。

## 是否创建临时对象

初始化：不创建。

赋值：传入形参时，创建。

