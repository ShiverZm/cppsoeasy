{"./":{"url":"./","title":"Introduction","keywords":"","body":"cppsoeasy 知识库 主要记录： 面试cpp的知识点 刷题记录 感谢以下网站提供的相关资料： Cpp Reference 帅地玩编程 c++面试题 C语言中文网 程序厨的算法小屋 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-03-02 12:13:48 "},"1-基础/":{"url":"1-基础/","title":"1-基础","keywords":"","body":"c和c++区别 C++是多范式编程（面向过程，面向对象，元编程，泛型编程）的语言，而C是面向过程的语言； C++引入new/delete运算符，取代了C中的malloc/free库函数； C++引入引用的概念，而C中没有； C++引入类的概念，而C中没有； C++引入函数重载的特性，而C中没有 元编程和泛型编程区别 元编程目的：代码生成代码 泛型编程目的：减小代码对特定数据类型的依赖 c++的模板元编程恰巧能同时做到。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 22:16:14 "},"1-基础/1.1-基础/":{"url":"1-基础/1.1-基础/","title":"1.1-基础","keywords":"","body":"Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 00:22:10 "},"1-基础/1.1-基础/1.1.1-c、c++区别.html":{"url":"1-基础/1.1-基础/1.1.1-c、c++区别.html","title":"1.1.1-c、c++区别","keywords":"","body":"c和c++区别 C++是面向对象的语言，而C是面向过程的语言； C++引入new/delete运算符，取代了C中的malloc/free库函数； C++引入引用的概念，而C中没有； C++引入类的概念，而C中没有； C++引入函数重载的特性，而C中没有 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 00:21:32 "},"1-基础/1.1-基础/1.1.10-内联函数.html":{"url":"1-基础/1.1-基础/1.1.10-内联函数.html","title":"1.1.10-内联函数","keywords":"","body":"内联函数 优点： 在内联函数被调用的地方进行代码展开，省去函数调用的时间，从而提高程序运行效率； 相比于宏函数，内联函数在代码展开时，编译器会进行语法安全检查或数据类型转换，使用更加安全； 缺点： 代码膨胀，产生更多的开销； 如果内联函数内代码块的执行时间比调用时间长得多，那么效率的提升并没有那么大； 如果修改内联函数，那么所有调用该函数的代码文件都需要重新编译； 内联声明只是建议，是否内联由编译器决定，所以实际并不可控。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 11:41:46 "},"1-基础/1.1-基础/1.1.2-a和&a区别.html":{"url":"1-基础/1.1-基础/1.1.2-a和&a区别.html","title":"1.1.2-a和&a区别","keywords":"","body":"Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 00:25:50 "},"1-基础/1.1-基础/1.1.3-static关键字作用.html":{"url":"1-基础/1.1-基础/1.1.3-static关键字作用.html","title":"1.1.3-static关键字作用","keywords":"","body":"static关键字作用 一般标识修饰的变量保存在静态存储区 c语言只能修饰局部静态变量和外部静态变量； C++，除了修饰局部静态变量和外部静态变量，还用来定义类的成员变量和函数。即静态成员和静态成员函数。 1.修改局部变量 该变量在 静态存储区 分配内存； 该变量只能在首次函数调用中进行首次初始化，之后的函数调用不再进行初始化； 该变量的生命周期与程序相同，但其作用域为局部作用域，并不能一直被访问； 2.修饰全局变量 修饰全局变量时，使得该变量在静态存储区 分配内存； 在声明该变量的整个文件中都是可见的，而在文件外是不可见的 3.修饰函数时 在声明该函数的整个文件中都是可见的，而在文件外是不可见的，从而可以在多人协作时避免同名的函数冲突； 4.修饰成员变量时 所有的对象都只维持一份拷贝，可以实现不同对象间的数据共享； 不需要实例化对象即可访问；不能在类内部初始化，一般在类外部初始化，并且初始化时不加static； 5. 修饰成员函数时 该函数不接受this指针，只能访问类的静态成员（函数和变量）； 不需要实例化对象即可访问。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 10:33:52 "},"1-基础/1.1-基础/1.1.4-变量的声明和定义.html":{"url":"1-基础/1.1-基础/1.1.4-变量的声明和定义.html","title":"1.1.4-变量的声明和定义","keywords":"","body":"变量的声明和定义 变量的定义为变量分配地址和存储空间， 变量的声明不分配地址。 (变量声明时会预定物理存储器，定义会分配物理存储器/使用物理存储器) 一个变量可以在多个地方声明， 但是只在一个地方定义。 加入extern 修饰的是变量的声明，说明此变量将在文件以外或在文件后面部分定义。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 00:53:00 "},"1-基础/1.1-基础/1.1.5-volatile作用以及注意点.html":{"url":"1-基础/1.1-基础/1.1.5-volatile作用以及注意点.html","title":"1.1.5-volatile作用以及注意点","keywords":"","body":"Volatile作用 修饰变量，标识编译器对访问该变量的代码就不再进行优化，常常用在多线程中，表示变量用完会写回内存中，而不是读取寄存器的备份。 注意点 指针也可以是volatile属性的，例如 volatile int * pInt; 一个参数可以既是const又是volatile 用const和volatile同时修饰变量，表示这个变量在程序内部是只读的，不能改变的，只在程序外部条件变化下改变，并且编译器不会优化这个变量。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 10:47:28 "},"1-基础/1.1-基础/1.1.6-全局变量和局部变量.html":{"url":"1-基础/1.1-基础/1.1.6-全局变量和局部变量.html","title":"1.1.6-全局变量和局部变量","keywords":"","body":"全局变量 存储位置：进程的全局数据段。 生命周期：程序运行到结束 特点：全局变量是整个程序都可访问的变量，谁都可以访问，生存期在整个程序从运行到结束（在程序结束时所占内存释放）； 局部变量 存储位置：进程的堆栈。 生命周期：作用域范围内。 特点：局部变量存在于模块（子程序，函数）中，只有所在模块可以访问，其他模块不可直接访问，模块结束（函数调用完毕），局部变量消失，所占据的内存释放。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 10:50:10 "},"1-基础/1.1-基础/1.1.7-memcpy、sprintf和strcpy.html":{"url":"1-基础/1.1-基础/1.1.7-memcpy、sprintf和strcpy.html","title":"1.1.7-memcpy、sprintf和strcpy","keywords":"","body":"memcpy、sprintf和strcpy 区别 memcpy sprintf strcpy 操作对象不同 memcpy 的两个对象就是两个任意可操作的内存地址，并不限于何种数据类型 sprintf 的操作源对象可以是多种数据类型， 目的操作对象是字符串 strcpy 的两个操作对象均为字符串 执行效率不同 memcpy 最高 sprintf 的效率最低 strcpy 次之 实现功能不同 memcpy 主要是内存块间的拷贝 sprintf 主要实现其他数据类型格式到字 符串的转化 strcpy 主要实现字符串变量间的拷贝 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 10:55:58 "},"1-基础/1.1-基础/1.1.8-memcpy、memmove和memccpy.html":{"url":"1-基础/1.1-基础/1.1.8-memcpy、memmove和memccpy.html","title":"1.1.8-memcpy、memmove和memccpy","keywords":"","body":"memcpy void *memcpy( void *dst, const void *src, size_t count ); 功能：拷贝src地址 count字节 到dst地址 返回值：该函数返回一个指向目标存储区 dst 的指针。 memmove void *memmove( void *dst, const void *src, size_t count ); 功能：memmove用于拷贝字节，如果目标区域和源区域有重叠的话，memmove能够保证源串在被覆盖之前将重叠区域的字节拷贝到目标区域中，但复制后源内容会被更改。但是当目标区域与源区域没有重叠则和memcpy函数功能相同 memccpy void *memccpy( void *dest, void *src, unsigned char c, unsigned int count ); 功能：由src所指内存区域复制不多于count个字节到dest所指内存区域，如果遇到字符c则停止复制。 返回值：如果c没有被复制，则返回NULL，否则，返回一个指向紧接着dest区域后的字符的指针。 区别与相同 相同：这三个函数的功能均是将某个内存块复制到另一个内存块， 区别：唯一的区别是，当内存发生局部重叠的时候，memmove保证拷贝的结果是正确的，memcpy不保证拷贝的结果的正确。 内存重叠问题 拷贝的目的地址在源地址的范围内，有重叠。 例如： char s[32] = \"abcdefg\"; char* p = s; p++: strcpy(p, s); Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 10:59:44 "},"1-基础/1.1-基础/1.1.9-共用体.html":{"url":"1-基础/1.1-基础/1.1.9-共用体.html","title":"1.1.9-共用体","keywords":"","body":"共用体 常见问题 字节对齐 当说明一个共用体变量时，系统分配给它的内存的大小是： 当最大的变量的大小 ```cpp union TestUnion { int a;// 4 byte float b;//4 byte char c;//1 byte }; 输出结果是:4 2. 当最大的变量的大小 >= 最大类型的大小，是最大类型的整数倍。（要考虑内存对齐） ```cpp union TestUnion { int a;// 4 byte float b;//4 byte char c[12];//12 byte double d;//8 byte }; 输出结果是:16 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 11:11:36 "},"1-基础/1.2-数组/":{"url":"1-基础/1.2-数组/","title":"1.2-数组","keywords":"","body":"1.2 数组 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-27 22:20:10 "},"1-基础/1.2-数组/1.2.1-数组越界.html":{"url":"1-基础/1.2-数组/1.2.1-数组越界.html","title":"1.2.1-数组越界","keywords":"","body":"数组越界不报错 以下运行结果 int main2() { int i; int a[5] = {0}; for (i = 0; i 这段代码结果就是：无限循环输出。 原因： 数组越界不报错 只会警告：C6201:索引\"30\"超出了“O\"至\"4\"的有效范围(对于可能在堆栈中分配的缓冲区\"a\")。 越界访问会访问了修改了i值 a内存空间 从0x00CFF7E0到 0x00CFF7F2 20个字节 5个Int长度 i为0x00CFF7FC即位置 越界访问会访问到i值，同时a[i] = 0;会把i置空为0，导致i=0;所以会一直循环。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 11:09:16 "},"1-基础/1.3-字符串/":{"url":"1-基础/1.3-字符串/","title":"1.3-字符串","keywords":"","body":"Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 10:33:02 "},"1-基础/1.3-字符串/1.3.1-sizeof和strlen.html":{"url":"1-基础/1.3-字符串/1.3.1-sizeof和strlen.html","title":"1.3.1-sizeof和strlen","keywords":"","body":"sizeof 和strlen 的区别 类型 sizeof：是一个操作符； strlen：是库函数，string.h头文件里的； 形数类型 sizeof：sizeof的参数可以是数据的类型，也可以是变量； strlen：只能以结尾为‘\\0’的字符串作参数。 运行时期和作用 sizeof：编译器在编译时就计算出了sizeof的结果， strlen：strlen函数必须在运行时才能计算出来。 并且sizeof计算的是数据类型占内存的大小，而strlen计算的是字符串实际的长度。 数组做sizeof的参数不退化，传递给strlen就退化为指针了 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 10:37:40 "},"1-基础/1.4-指针与引用/":{"url":"1-基础/1.4-指针与引用/","title":"1.4-指针与引用","keywords":"","body":"指针 定义：指针是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。 形式： - 声明：type *var-name; 例如：int i = 10; int *pNum = &i; - 取值：*var-name; 例如: *pNum; 大小：4字节（32位程序），8字节（64位程序） 引用 一般指左值引用。 定义：引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。 形式： 声明：type &var-name = var; 例如：int &refNum = i; 大小：原类型大小，sizeof(type); 右值引用 c++11的特性 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 10:30:46 "},"1-基础/1.4-指针与引用/1.4.1-指针和引用的区别.html":{"url":"1-基础/1.4-指针与引用/1.4.1-指针和引用的区别.html","title":"1.4.1-指针和引用的区别","keywords":"","body":"指针和引用的区别 参考知乎：C++中指针与引用的区别 1. 两者的定义和性质不同 指针是一个变量，存储的是一个地址，指向内存的一个存储单元； 引用是原变量的一个别名，跟原来的变量实质上是同一个东西，跟原来的变量用的同一块内存。 2.指针可以有多级，引用只能是一级 int **p; // 合法 int &&a; // 不合法 3.指针可以在定义的时候不初始化，引用必须在定义的时候初始化 int *p; // 合法 int &r; // 不合法 int a = 996; int &r = a; // 合法 4.指针可以指向NULL，引用不可以为NULL int *p = NULL; // 合法 int &r = NULL; // 不合法 5.指针初始化之后可以再改变，引用不可以 int a = 996; int *p = &a; // 初始化, p 是 a 的地址 int &r = a; // 初始化, r 是 a 的引用 int b = 885; p = &b; // 合法, p 更改为 b 的地址 r = b; // 不合法, r 不可以再变 6.sizeof 的运算结果不同 指针大小：4字节或8字节，根据程序位数有关； 引用大小：是原对象的大小； int a = 996; int *p = &a; int &r = a; cout 7、自增运算意义不同 指针自增：指针地址偏移一个type单位； 引用自增：原对象的值自增； int a = 996; int *p = &a; int &r = a; p++;//p++之后指向a后面的内存 r++;//r++相当于a++。 8.指针和引用作为函数参数时，指针需要检查是否为空，引用不需要 void fun_p(int *p) { // 需要检查P是否为空 if (p == NULL) { // do something } } void fun_r(int &r) { // 不需要检查r // do something } Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-27 19:34:44 "},"1-基础/1.4-指针与引用/1.4.2-指针和引用使用的场景.html":{"url":"1-基础/1.4-指针与引用/1.4.2-指针和引用使用的场景.html","title":"1.4.2-指针和引用使用的场景","keywords":"","body":"指针和引用使用的场景 参考知乎：设计C++函数传参时如何决定使用指针还是引用？ 1. 函数不是构造函数，且参数是只读：用const引用。 如果函数参数是只读的，且不是构造函数，const引用最好。 原因： 如果用指针，用户使用时可能会传nullptr作为参数。 用引用的话，用户基本不可能犯这种错误。 const reference 可以接受匿名变量作为参数。 比如， 2.函数不是构造函数，且参数是作为输出(out)参数：用指针。 这种情况用指针最好。因为用户在传指针的时候需要用到取地址操作符(&)，这样代码看起来更易懂。 比如： void copy1(const std::string &a, std::string *b); void copy2(const std::string &a, std::string &b); copy1(foo, &bar);//指针输出 copy2(foo, bar);//引用作输出 3.函数不是构造函数，且不是只读，但也不是输出参数：用引用。 原因： 这种情况用引用比用指针好是引用可以防止不小心传nullptr这种情况。 4.函数是构造器，但参数并不参与组成构造类的一部分，那就参考以上几点。 5.函数是构造器，且参数参与构造，且参数是可移动的类型：传值。 这种情况直接传值是最好的。比如： class person { public: person(std::string name) : name_{std::move(name)} {} private: std::string name_; }; 传值比传const引用好处在于，取决于用户是否需要保留原参，可以省略复制。比如， Person p{\"Jack\"}; // 创建一个临时变量，如果一个move；多半情况下编译器会直接创建在Person里 std::string name{\"John\"}; Person p1{name}; // 这种情况跟用const引用一样，都是一次copy Person p2{std::move(name)}; // 因为被转化成了右值，name会被直接移动到p2里，省掉一次copy 当然，如果string是像这个例子中这么小的话，move和copy开销是一样的，因为small string optimization。 但如果参数是长的string，或者类似于vector或者map这种heap allocated变量的话，move就比copy开销小非常多。 6. 函数是构造器，且参数参与构造，但构造的类只保留参数的引用：传shared_ptr或者自定义指针（不推荐） 首先我非常不提倡这种类型，因为如果这样定义，用户就必须保证name的生命周期比person长。但只看构造器的签名的话又没办法看出来这点。用起来非常麻烦，每次都需要查文档或者读代码才能知道用name构建了person之后能不能销毁name。比如如果你这样定义这个类： class person { public: person(const family_tree &family) : family_{&name} { family_->add(this); } private: const family_tree *family_; }; family_tree family{...}; person p{family}; //只看这两行代码你能知道可不可以return p吗？ 我一般只有当类是作为函数类型用的时候才会定义这种类型。其他情况，我一般会用shared_ptr作为参数，然后类里也保存shared_ptr作为成员。比如像这样， class person { public: person(std::shared_ptr family) : family_{std::move(family)} {} private: std::shared_ptr family_; }; 但这样如果family是stack上的变量且我可以保证family的生命周期比person长怎么办？其实很容易，这样就行了： int main() { family_tree family{...}; person p{shared_ptr(&family, [](family_tree *) {})}; ... } Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-27 22:18:50 "},"1-基础/1.4-指针与引用/1.4.3-delete、free和new、malloc的异同.html":{"url":"1-基础/1.4-指针与引用/1.4.3-delete、free和new、malloc的异同.html","title":"1.4.3-delete、free和new、malloc的异同","keywords":"","body":"delete、free和new、malloc的异同 new、malloc区别 区别点 new malloc 1.申请的内存所在位置 自由存储区（free store）上为对象动态分配内存空间 从堆上动态分配内存。 2.返回类型安全性 返回标准类型指针。 返回void* 3.内存分配失败时的返回值 内存分配失败时，会抛出bac_alloc异常，它不会返回NULL； 分配内存失败时返回NULL。 4.是否需要指定内存大小 申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算， 需要显式地指出所需内存的尺寸。 5.是否调用构造函数/析构函数 调用构造 不调用 6.对数组的处理，C++提供了new[]与delete[]来专门处理数组类型 7.new与malloc是否可以相互调用 8.是否可以被重载 new/delete可以重载 free/malloc是函数，可以写同名函数，重载函数。 9.能够直观地重新分配内存 10.客户处理内存分配不足 自由存储区：C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。 堆：操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。 注意： 自由存储区是否是堆：需要看new的实现，自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。 注意： delete一般是不可以释放malloc的资源，free和new一样。但对于简单类型单单释放是不会报错的，对于对象类型的话，可能会存在问题。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-27 22:59:28 "},"1-基础/1.4-指针与引用/1.4.4-野指针.html":{"url":"1-基础/1.4-指针与引用/1.4.4-野指针.html","title":"1.4.4-野指针","keywords":"","body":"野指针 定义：指针指向未知内存，导致访问越界/非法访问等问题。 几种情况： 指针没初始化 指针指向的内存释放后，指针没置空 指针操作超越了变量的作用范围 如何避免野指针 指针变量声明时没有被初始化。 解决办法：指针声明时初始化，可以是具体的地址值，也可让它指向NULL。 指针p被free或者delete之后，没有置为NULL。 解决办法：指针指向的内存空间被释放后指针应该指向NULL。 指针操作超越了变量的作用范围。 解决办法：在变量的作用域结束前释放掉变量的地址空间并且让指针指向NULL。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 12:46:30 "},"1-基础/1.4-指针与引用/1.4.5-内存泄漏.html":{"url":"1-基础/1.4-指针与引用/1.4.5-内存泄漏.html","title":"1.4.5-内存泄漏","keywords":"","body":"内存泄漏 定义：堆区内存（new/malloc）没有释放，导致运行时内存增加，直到一定程度导致程序崩溃。 内存泄漏场景 malloc和free未成对出现；new/new []和delete/delete []未成对出现； 1>在堆中创建对象分配内存，但未显式释放内存；比如，通过局部分配的内存，未在调用者函数体内释放： 2>在构造函数中动态分配内存，但未在析构函数中正确释放内存； 未定义拷贝构造函数或未重载赋值运算符，从而造成两次释放相同内存的做法；比如，类中包含指针成员变量，在未定义拷贝构造函数或未重载赋值运算符的情况下，编译器会调用默认的拷贝构造函数或赋值运算符，以逐个成员拷贝的方式来复制指针成员变量，使得两个对象包含指向同一内存空间的指针，那么在释放第一个对象时，析构函数释放该指针指向的内存空间，在释放第二个对象时，析构函数就会释放同一内存空间，这样的行为是错误的； 没有将基类的析构函数定义为虚函数。 内存泄漏常见解决方案 MFC DEBUG_NEW 重载new/delete Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 00:55:22 "},"1-基础/1.4-指针与引用/1.4.6-悬挂指针.html":{"url":"1-基础/1.4-指针与引用/1.4.6-悬挂指针.html","title":"1.4.6-悬挂指针","keywords":"","body":"悬挂指针 悬挂指针：当指针所指向的对象被释放，但是该指针没有任何改变，以至于其仍然指向已经被回收的内存地址，这种情况下该指针被称为悬挂指针； 野指针 野指针：未初始化的指针被称为野指针。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 11:21:26 "},"1-基础/1.4-指针与引用/1.4.7-指针常量与常量指针区别.html":{"url":"1-基础/1.4-指针与引用/1.4.7-指针常量与常量指针区别.html","title":"1.4.7-指针常量与常量指针区别","keywords":"","body":"指针常量 本质是一个常量，而用指针修饰它。指针常量的值是指针，这个值因为是常量，所以不能被赋值。 形式： int* const p; 注意： 它是个常量！ 指针所保存的地址可以改变，然而指针所指向的值却不可以改变； 指针本身是常量，指向的地址不可以变化,但是指向的地址所对应的内容可以变化； 常量指针 常指针，指向一个常量的指针。 形式： int const* p; const int* p; 例如： const int i =123;//常量 int const* p = i; //指向常量的指针 注意： 常指针不能通过指针修改值的内容。（常量不可修改） 指针还可以指向别处，因为指针本身只是个变量，可以指向任意地址。 指向常量的常指针 指向常量的指针常量就是一个常量，且它指向的对象也是一个常量。 形式： const int* const p; 注意： 一个指针常量，指向的是一个指针对象； 它指向的指针对象且是一个常量，即它指向的对象不能变化； 区别 是否是常量 指针指向的内容是否可以修改 是否可以通过指针修改指向的内容 指针常量 是 是 否 常量指针 否 是 否 指向常量的常（量）指针 是 否 否 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 12:44:56 "},"1-基础/1.4-指针与引用/1.4.8-句柄和指针.html":{"url":"1-基础/1.4-指针与引用/1.4.8-句柄和指针.html","title":"1.4.8-句柄和指针","keywords":"","body":"句柄 句柄：暴露部分数据结构和结构，隐藏不想暴露的部分。 Windows系统用句柄标记系统资源，隐藏系统的信息。你只要知道有这个东西，然后去调用就行了，它是个32it的uint。 例如： Windows 窗口句柄 HWND hWnd; 句柄和指针区别 Windows系统用句柄标记系统资源，隐藏系统的信息。你只要知道有这个东西，然后去调用就行了，它是个32it的uint。 指针则标记某个物理内存地址，两者是不同的概念。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 12:49:18 "},"1-基础/1.5-面向对象/":{"url":"1-基础/1.5-面向对象/","title":"1.5-面向对象","keywords":"","body":"c和c++区别 C++是面向对象的语言，而C是面向过程的语言； C++引入new/delete运算符，取代了C中的malloc/free库函数； C++引入引用的概念，而C中没有； C++引入类的概念，而C中没有； C++引入函数重载的特性，而C中没有 面向对象基本特征 封装，继承，多态。 封装 定义：就是隐藏对象的属性和实现细节，仅对外公开接口（method），控制在程序中属性的读和修改的访问级别（public/protected/private）。 目的：封装的目的是增强安全性和简化编程，使用者不必了解具体的实现细节，而只是要通过外部接口，以特定的访问权限来使用类的成员。 继承 是面向对象的基本特征之一，继承机制允许创建分等级层次的类。 定义：继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。 注意：C++支持多重继承（java只支持 单继承），可能会导致菱形继承。 多态 定义：多态同一个行为具有多个不同表现形式或形态的能力。是指一个类实例（对象）的相同方法在不同情形有不同表现形式。（主要体现在重写和重载，上转型） Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 00:21:56 "},"1-基础/1.5-面向对象/1.5.1-重写和覆盖的区别.html":{"url":"1-基础/1.5-面向对象/1.5.1-重写和覆盖的区别.html","title":"1.5.1-重写和覆盖的区别","keywords":"","body":"重写和覆盖的区别 重写：基类有virtual， 派生类继承过来，重新实现函数。如果上转，则调用子类的。 覆盖：基类没有virtual，派生类有基类同名且同参数返回值的函数，基类和派生类都有这个函数，互不干扰。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-27 23:04:38 "},"1-基础/1.5-面向对象/1.5.10-虚继承.html":{"url":"1-基础/1.5-面向对象/1.5.10-虚继承.html","title":"1.5.10-虚继承","keywords":"","body":"虚继承 为了解决多继承时的命名冲突和冗余数据问题，C++提出了虚继承，使得在派生类中只保留一份间接基类的成员。 在继承方式前面加上 virtual 关键字就是虚继承，请看下面的例子： //间接基类A class A{ protected: int m_a; }; //直接基类B class B: virtual public A{ //虚继承 protected: int m_b; }; //直接基类C class C: virtual public A{ //虚继承 protected: int m_c; }; //派生类D class D: public B, public C{ public: void seta(int a){ m_a = a; } //正确 void setb(int b){ m_b = b; } //正确 void setc(int c){ m_c = c; } //正确 void setd(int d){ m_d = d; } //正确 private: int m_d; }; int main(){ D d; return 0; } Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 16:01:06 "},"1-基础/1.5-面向对象/1.5.11-空类的大小和成员函数.html":{"url":"1-基础/1.5-面向对象/1.5.11-空类的大小和成员函数.html","title":"1.5.11-空类的大小和成员函数","keywords":"","body":"空类的大小 sizeof(A)的值为1，因为编译器需要区分这个空类的不同实例，分配一个字节，可以使这个空类的不同实例拥有独一无二的地址。 空类的成员函数 缺省构造函数()。 缺省拷贝构造函数copy()。 省析构函数~()。 赋值运算符opreate=。 取址运算符operator&。 取址运算符 operator& const 。 注意： 有些书上只是简单的介绍了前四个函数。没有提及后面这两个函数。但后面这两个函数也是 空类的默认函数。另外需要注意的是，只有当实际使用这些函数的时候，编译器才会去定义它们。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 16:39:14 "},"1-基础/1.5-面向对象/1.5.12-类和结构体的区别.html":{"url":"1-基础/1.5-面向对象/1.5.12-类和结构体的区别.html","title":"1.5.12-类和结构体的区别","keywords":"","body":"struct和class 默认继承权限不同，class继承默认是private继承，而struct默认是public继承 模板参数， class还可用于定义模板参数，像typename，但是关键字struct不能用于定义模板参数 C++保留struct关键字，主要有如下原因 兼容C语言：保证与C语言的向下兼容性，C++必须提供一个struct C++中的struct定义必须百分百地保证与C语言中的struct的向下兼容性，把C++中的最基本的对象单元规定为class而不是struct，就是为了避免各种兼容性要求的限制 便于移植C语言，对struct定义的扩展使C语言的代码能够更容易的被移植到C++中 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 16:16:28 "},"1-基础/1.5-面向对象/1.5.2-多态的具体表现.html":{"url":"1-基础/1.5-面向对象/1.5.2-多态的具体表现.html","title":"1.5.2-多态的具体表现","keywords":"","body":"几种具体的表现 重写 子类继承父类后对父类方法进行重新定义。 重载 对已有方法的参数类型和数量的改变。 覆盖 基类没有virtual，派生类有基类同名且同参数返回值的函数 上转型（子类转父类） 父类引用指向子类对象。 Parent* pParent = new Child; Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-27 23:06:24 "},"1-基础/1.5-面向对象/1.5.3-多态的实现.html":{"url":"1-基础/1.5-面向对象/1.5.3-多态的实现.html","title":"1.5.3-多态的实现","keywords":"","body":"多态的实现 多态分为静态多态和动态多态。 静态多态、 其中，静态多态是通过重载和模板技术实现的，在编译期间确定； 动态多态 动态多态是通过虚函数和继承关系实现的，执行动态绑定，在运行期间确定。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-27 23:23:48 "},"1-基础/1.5-面向对象/1.5.4-构造和析构函数.html":{"url":"1-基础/1.5-面向对象/1.5.4-构造和析构函数.html","title":"1.5.4-构造和析构函数","keywords":"","body":"构造函数 析构函数 对象创建到销毁构造析构调用顺序 A：基类； B：派生类； 从创建到销毁构造析构调用顺序。 graph TB A(A构造)-->B(B构造); B-->C(B析构); C-->D(A析构); 常见问题 1.构造函数不可以是虚函数 虚函数的调用依赖于虚函数表，而指向虚函数表的指针vptr需要在构造函数中进行初始化，所以无法调用定义为虚函数的构造函数。 2.构造/析构函数不占据内存空间 对象的大小是指在类实例化出的对象当中，他的数据成员所占据的内存大小，而不包括成员函数，所以不占用。 3.基类的析构函数需要定义为虚函数 为了实现动态绑定，基类指针指向派生类对象，如果析构函数不是虚函数，那么在对象销毁时，就会调用基类的析构函数，只能销毁派生类对象中的部分数据，所以必须将析构函数定义为虚函数，从而在对象销毁时，调用派生类的析构函数，从而销毁派生类对象中的所有数据。 主要是： 多态上转型接收时 如果不是虚析构，对象销毁时会调用基类的析构函数。 同时，虚析构时，才会调用到派生类的析构。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 15:45:58 "},"1-基础/1.5-面向对象/1.5.5-构造初始化.html":{"url":"1-基础/1.5-面向对象/1.5.5-构造初始化.html","title":"1.5.5-构造初始化","keywords":"","body":"拷贝初始化和直接初始化区别 类型 形式 说明 直接初始化 ClassTest ct1(“ab”) 它不需要调用复制构造函数，直接调用构造函数ClassTest(constchar *pc)，所以当复制构造函数变为私有时，它还是能直接执行的。 ClassTest ct4（ct1） 因为 ct1 本来已经存在，直接调用复制构造函数，生成对象 ct3 的副本对象 ct4。所以当复制构造函数变为私有时，该语句不能编译通过。 复制初始化 ClassTest ct2 = “ab” 它首先调用构造函数 ClassTest(const char* pc) 函数创建一个临时对象， 然后调用复制构造函数，把这个临时对象作为参数，构造对象ct2；所以当复制构造函数变为私有时，该语句不能编译通过。 ClassTest ct3 = ct1; 因为 ct1 本来已经存在，所以不需要调用相关的构造函数，而直接调用复制构造函数把它值复制给对象 ct3；所以当复制构造函数变为私有时，该语句不能编译通过。 初始化和赋值的区别 调用的函数不同 初始化：调用构造函数。 赋值：调用复制构造函数。 是否创建临时对象 初始化：不创建。 赋值：传入形参时，创建。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 13:28:54 "},"1-基础/1.5-面向对象/1.5.6-纯虚函数作用.html":{"url":"1-基础/1.5-面向对象/1.5.6-纯虚函数作用.html","title":"1.5.6-纯虚函数作用","keywords":"","body":"纯虚函数 定义纯虚函数是为了实现一个接口，起到规范的作用，想要继承这个类就必须覆盖该函数。 形式 实现方式是在虚函数声明的结尾加上= 0即可。 class AbstractClasss{ publi: virtual void Export() = 0; } 作用 定义纯虚函数是为了实现一个接口，起到规范的作用，对外表示接口。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 15:29:02 "},"1-基础/1.5-面向对象/1.5.7-虚函数表.html":{"url":"1-基础/1.5-面向对象/1.5.7-虚函数表.html","title":"1.5.7-虚函数表","keywords":"","body":"虚函数表 虚函数表是针对类的，类的所有对象共享这个类的虚函数表。 因为每个对象内部都保存一个指向该类虚函数表的指针vptr，每个对象的vptr的存放地址都不同，但都指向同一虚函数表。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 15:32:10 "},"1-基础/1.5-面向对象/1.5.8-禁止类的实例化.html":{"url":"1-基础/1.5-面向对象/1.5.8-禁止类的实例化.html","title":"1.5.8-禁止类的实例化","keywords":"","body":"禁止类的实例化 方法 声明为private 将类定义为抽象类（也就是存在纯虚函数）或者将构造函数声明为private。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 15:49:16 "},"1-基础/1.5-面向对象/1.5.9-多继承相关.html":{"url":"1-基础/1.5-面向对象/1.5.9-多继承相关.html","title":"1.5.9-多继承相关","keywords":"","body":"多继承可能存在的问题 增加程序的复杂度， 使得程序的编写和维护比较困难，容易出错； 成员变量的同名二义性：在继承时，基类之间或基类与派生类之间发生成员同名时，将出现对成员访问的不确定性，即同名二义性； 消除多继承中的二义性： 利用作用域运算符::，用于限定派生类使用的是哪个基类的成员； 在派生类中定义同名成员，覆盖基类中的相关成员； 成员变量的路径二义性 当派生类从多个基类派生，而这些基类又从同一个基类派生，则在访问此共同基类的成员时，将产生另一种不确定性，即路径二义性；（菱形继承） 消除路径二义性的方法： 消除同名二义性的两种方法都可以； 使用虚继承，使得不同路径继承来的同名成员在内存中只有一份拷贝。 （class A：virtual public Base） Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 16:00:30 "},"1-基础/1.7-宏定义/1.7.2-typedef和define.html":{"url":"1-基础/1.7-宏定义/1.7.2-typedef和define.html","title":"1.7.2-typedef和define","keywords":"","body":"typedef typedef 和define区别 用法不同：typedef 用来定义一种数据类型的别名，增强程序的可读性。define 主要用来定义 常量，以及书写复杂使用频繁的宏。 执行时间不同：typedef 是编译过程的一部分，有类型检查的功能。define 是宏定义，是预编译的部分，其发生在编译之前，只是简单的进行字符串的替换，不进行类型的检查。 作用域不同：typedef 有作用域限定。define 不受作用域约束，只要是在define 声明后的引用 都是正确的。 对指针的操作不同：typedef 和define 定义的指针时有很大的区别。 注意： typedef 定义是语句，因为句尾要加上分号。而define 不是语句，千万不能在句尾加分号。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 12:02:44 "},"1-基础/1.1-整型.html":{"url":"1-基础/1.1-整型.html","title":"1.1-整型","keywords":"","body":"1.1-整型 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-03-02 22:55:40 "},"2-高级/":{"url":"2-高级/","title":"2-高级","keywords":"","body":"2.高级篇 主要： 标准库 STL string 容器（数据的存放形式，包括序列式容器和关联式容器） 算法库（排序，复制等常用算法，以及不同容器特定的算法） 迭代器（就是在不暴露容器内部结构的情况下对容器的遍历） 时间库（时间、日期、本地化库） 线程库 文件操作 面向对象 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 16:58:18 "},"2-高级/2.1-string/":{"url":"2-高级/2.1-string/","title":"2.1-string","keywords":"","body":"std::string C++ 98的特性 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 01:03:26 "},"2-高级/2.1-string/2.1.1-string的sizeof.html":{"url":"2-高级/2.1-string/2.1.1-string的sizeof.html","title":"2.1.1-string的sizeof","keywords":"","body":"sizeof std::string sizeof(std::string)的结果 可能是 4、12，32\\28。 string的实现在各库中可能有所不同，但是在同一库中相同一点是，无论你的string里放多长的字符串，它的sizeof()都是固定的，字符串所占的空间是从堆中动态分配的，与sizeof()无关。 sizeof(string) == 4 可能是最为典型的实现之一， 不过也有sizeof()为 12，32 字节的库， 同时也与编译器有关，在windows 32位操作系统下， 使用vs2013/vs2015编译器测试，sizeof(string) == 28。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 01:00:36 "},"2-高级/2.10-线程库/":{"url":"2-高级/2.10-线程库/","title":"2.10-线程库","keywords":"","body":"线程库 std::thread Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 23:02:18 "},"2-高级/2.10-线程库/2.10.1-thread.html":{"url":"2-高级/2.10-线程库/2.10.1-thread.html","title":"2.10.1-thread","keywords":"","body":"Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 23:02:02 "},"2-高级/2.10-线程库/2.10.2-常见的锁.html":{"url":"2-高级/2.10-线程库/2.10.2-常见的锁.html","title":"2.10.2-常见的锁","keywords":"","body":"[TOC] 常见的锁 按功能分类 互斥锁/独占锁/排他锁 std::mutex 互斥变量，申请内核锁。 std::lock_guard 在std::lock_guard变量创建时内 加锁，生命周期结束就释放锁。俗称c++ RAII 资源管理机制 std::unique_lock C++11中std::unique_lock的使用 std::unique_lock为锁管理模板类，是对通用mutex的封装。std::unique_lock对象以独占所有权的方式(uniqueowership)管理mutex对象的上锁和解锁操作，即在unique_lock对象的声明周期内,它所管理的锁对象会一直保持上锁状态； 而unique_lock的生命周期结束之后，它所管理的锁对象会被解锁。 unique_lock具有lock_guard的所有功能，而且更为灵活。 虽然二者的对象都不能复制，但是unique_lock可以移动(movable)，因此用unique_lock管理互斥对象，可以作为函数的返回值，也可以放到STL的容器中。 递归锁/嵌套锁/可重入锁 在不同的线程中调用已锁定的互斥锁，必然会导致死锁。 但是在同一个线程中，如果想要多次获得一个锁，只能使用递归锁。 举例来说，如果函数A,B都有枷锁逻辑；而在特殊条件下，函数A用调用了函数B; 则需要用递归锁。 应尽量避免使用递归锁，好的设计会避免锁的多次使用 std::recursive_mutex std::recursive_mutex 允许同一个线程对互斥量多次上锁（即递归上锁），来获得对互斥量对象的多层所有权，std::recursive_mutex 释放互斥量时需要调用与该锁层次深度相同次数的 unlock() 自旋锁 C++性能优化（十二）——自旋锁 自旋锁是一种非阻塞锁，也就是说，如果某线程需要获取自旋锁，但该锁已经被其他线程占用时，该线程不会被挂起，而是在不断的消耗CPU的时间，不停的试图获取自旋锁。 共享锁 c++ 17才有 boost:share_mutex 读写锁 c++ 20 原子锁 std::atomic std::atomic对int, char, bool等数据结构进行原子性封装，在多线程环境中，对std::atomic对象的访问不会造成竞争-冒险。利用std::atomic可实现数据结构的无锁设计。 可参考 c++语言：从放弃到入门 ＜一＞ c++11新关键字以及引入的新特性 std::atomic std::atomic_flag std::atomic_flag是一个原子的布尔类型，可支持两种原子操作： test_and_set, 如果atomic_flag对象被设置，则返回true; 如果atomic_flag对象未被设置，则设置之，返回false clear. 清楚atomic_flag对象 　　std::atomic_flag可用于多线程之间的同步操作，类似于linux中的信号量。使用atomic_flag可实现mutex. 同步锁 按特征分类 悲观锁 前面提到的互斥锁、自旋锁、读写锁，都是属于悲观锁。 悲观锁做事比较悲观，它认为多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁。 乐观锁 乐观锁做事比较乐观，它假定冲突的概率很低，它的工作方式是：先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。 乐观锁虽然去除了加锁解锁的操作，但是一旦发生冲突，重试的成本非常高，所以只有在冲突概率非常低，且加锁成本非常高的场景时，才考虑使用乐观锁。 二、常见性质 原子性 三、常见的概念 互斥量 信号量 条件变量 std::condition_variable 基本用法: //创建条件变量和互斥锁 std::condition_variable m_notification; std::mutex m_mutex; ... //添加队列数据时加锁，并唤起一个正在阻塞wait()的线程 std::unique_lock autoLock(m_mutex); ... m_notification.notify_one();//唤起一个正在阻塞wait()的线程 ... //当当前队列没有数据时 阻塞 std::unique_lock autoLock(m_mutex); m_notification.wait(autoLock);//把当前线程阻塞 当消费者线程调用wait时 线程进入阻塞状态，当调用notify_one唤醒消费者线程，线程进入可运行状态。 运用顺序打印 C++ 3个线程顺序输出1-9 std::condition_variable_any 互斥问题 比如多个线程对公共资源的使用管理问题，即互斥问题(Exclusive)； 同步问题 各种依赖关系，比如线程1的工作要基于线程2的工作才能执行，即同步问题(Synchronization)。 三、线程状态转移 线程的状态在操作系统层面和JAVA API层面的区别 初始状态 仅是在语言层面创建了线程对象，还未与操作系统线程关联。 类似c++创建线程状态 std::thread hStartFun; 可运行状态(就绪状态) （就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行，等待获取CPU的使用权。即在就绪状态的进程除CPU之外，其它的运行所需资源都已全部获得。 阻塞状态（等待状态/挂起状态） 线程——运行和阻塞状态详解 当发生如下情况时，线程将进入阻塞状态： 1、线程调用了sleep()方法主动放弃其所占用的处理器资源；Sleep() 2、线程调用了一个阻塞式I/O方法，在该方法返回之前，该线程被阻塞；WaitForSingleObject() 3、线程试图调用一个锁对象，但该锁对象整备其他线程所持有的；try_lock() 4、线程正在等待某个通知 wait() 当前正在执行的线程被阻塞之后，其他线程就可以后的执行的机会。被阻塞的线程会在合适的时候重新进入就绪状态，注意是就绪状态，而不是运行状态。也就是说，被阻塞线程的阻塞解除之后，必须重新等待线程调度再次调度它。 针对上面几种情况，当发生如下特定的情况时可以解除阻塞，让该线程重新进入就绪状态。 1、调用sleep()方法的线程超过了指定的时间； 2、线程调用的阻塞式I/O方法已经返回； 3、线程成功的获得了试图获取的锁对象； 4、线程正在等待某个通知时，其他线程发出了一个通知。 运行状态 指获取了 CPU 时间片运行中的状态 当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换。 终止状态 表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态 四、使用多线程基本准则 1.尽可能的减小锁定的区域 互斥锁保证了线程间的同步，但是却将并行操作变成了串行操作，这对性能有很大的影响，所以我们要尽可能的减小锁定的区域，也就是使用细粒度锁。 五、多线程常用场景 1.生产者消费者队列 push/pop时都需要加锁 总结 1.互斥锁和自旋锁 互斥锁加锁失败后，线程会释放 CPU ，给其他线程； 自旋锁加锁失败后，线程会忙等待，直到它拿到锁； 互斥锁缺点： （1）等待互斥锁会消耗时间，等待延迟会损害系统的可伸缩性。 （2）优先级倒置。低优先级的线程可以获得互斥锁，因此会阻碍需要同一互斥锁的高优先级线程。 （3）锁护送（lock convoying）。如果持有互斥锁的线程分配的时间片结束，线程被取消调度，则等待同一互斥锁的其它线程需要等待更长时间。 2.sleep和wait 当线程调用了wait()方法时，它会释放掉对象的锁. sleep()，它会导致线程睡眠指定的毫秒数，但线程在睡眠的过程中是不会释放掉对象的锁的. Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 23:01:48 "},"2-高级/2.2-容器/":{"url":"2-高级/2.2-容器/","title":"2.2-容器","keywords":"","body":"容器 顺序容器 顺序容器实现能按顺序访问的数据结构。 vector：动态的连续数组 list：双向链表 array ：（C++11）静态的连续数组 deque：双端队列 forward_list：（C++11）单链表 关联容器 关联容器实现能快速查找（O(log n) 复杂度）的数据结构。 set：唯一键的集合，按照键排序。 map：键值对的集合，按照键排序，键是唯一的。 multiset：键的集合，按照键排序。 multimap：键值对的集合，按照键排序。 无序关联容器 无序关联容器提供能快速查找（均摊 O(1) ，最坏情况 O(n) 的复杂度）的无序（哈希）数据结构。 unordered_set：（C++11）唯一键的集合，按照键生成散列。 unordered_map：（C++11）键值对的集合，按照键生成散列，键是唯一的 unordered_multiset：（C++11）键的集合，按照键生成散列。 unordered_multimap：（C++11）键值对的集合，按照键生成散列。 容器适配器 容器适配器提供顺序容器的不同接口。 stack：适配一个容器以提供栈（LIFO 数据结构）(类模板) queue：适配一个容器以提供队列（FIFO 数据结构）(类模板) priority_queue：适配一个容器以提供优先级队列(类模板) Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 20:45:14 "},"2-高级/2.2-容器/2.2.1-vector.html":{"url":"2-高级/2.2-容器/2.2.1-vector.html","title":"2.2.1-vector","keywords":"","body":"[TOC] vector vector底层是一个动态数组。 底层原理 当空间不够装下数据（vec.push_back(val)）时，会自动申请另一片更大的空间（1.5倍或者2倍），然后把原来的数据拷贝到新的内存空间，接着释放原来的那片空间【vector内存增长机制】。 当释放或者删除（vec.clear()）里面的数据时，其存储空间不释放，仅仅是清空了里面的数据。 初始化 方法一 vector vi; 方法二 vector vi(10,10);//size 10,each value 10 方法三 vector vi(arr,arr+10);//begin,end 插入 方法一 push_back vector a; T val; a.push_back( val);//在末尾插入一个元素 方法二 insert v2.insert(v2.begin()+4, L\"3\"); //在指定位置，例如在第五个元素前插入一个元素 v2.insert(v2.end(), L\"3\"); //在末尾插入一个元素 v2.insert(v2.begin(), L\"3\"); //在开头插入一个元素 查找 方法一 迭代器 #include ... vector vec; ... vector::iterator it = find(vec.begin(), vec.end(), value); if (it != vec.end()){ //找到了 } 方法二 数组查找 std::vector a; for (size_t i = 0; i 遍历 方法一 迭代器 std::vector a; std::vector ::iterator iVector = a.begin(); while(iVector != a.end()) { std::cout 方法二 数组 std::vector v1; for (size_t i = 0; i 删除 erase和clear区别 vector::clear()函数的作用是清空容器中的内容，但如果是指针对象的话，并不能清空其内容. clear 清空并释放内存,并回收内存. vector xx; for(int it=0;it!=xx.size();++it) { delete xx[it]; } xx.clear(); xx.swap(vector()); vector::erase()用于清空容器中的内容以及释放内存,并返回指向删除元素的下一个元素的迭代器。 删除最后一个元素 v1.pop_back(); //删除最后一个元素 删除开头的元素 v1.erase(v2.begin()); //删除开头的元素 删除[begin,end]区间的元素 v1.erase(v1.begin(),v1.end); 删除全部元素 方法一 v1.clear() 方法二 std::vector::iterator iVector = v1.begin(); while(iVector != v1.end()) { delete (*iVector)->p; iVector = v1.erase(iVector); } 方法三 while(pVector->size() != 0) { //pop_back方法无返回值 pVector->pop_back(); //删除操作避免大量移动的方法，如果元素有申请堆栈的内存，不可用此方法 } vector常见问题 1.push_back 与 emplace_back(c++11)区别 相同点 都是在 vector 容器的尾部添加一个元素。 不同点 push_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）； 而emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。 总之,emplace会减少拷贝或者移动元素的过程,减少拷贝耗时. 2.频繁对vector调用push_back()对性能的影响和原因 vector需要不断调整容量，容量调整过程是需要从旧容器拷贝到新的是原来容量1.5倍的大小的新容器中。 拷贝过程中耗时。 3.vector中的reserve和resize的区别 reserve： 是直接扩充到已经确定的大小，可以减少多次开辟、释放空间的问题（优化push_back），就可以提高效率，其次还可以减少多次要拷贝数据的问题。reserve只是保证vector中的空间大小（capacity）最少达到参数所指定的大小n。reserve()只有一个参数。 resize：可以改变有效空间的大小，也有改变默认值的功能。capacity的大小也会随着改变。resize()可以有多个参数。 4.为什么vector的插入操作可能会导致迭代器失效 vector动态增加大小时，并不是在原空间后增加新的空间，而是以原大小的两倍在另外配置一片较大的新空间，然后将内容拷贝过来，并释放原来的空间。由于操作改变了空间，所以迭代器失效。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 22:49:54 "},"2-高级/2.2-容器/2.2.2-list.html":{"url":"2-高级/2.2-容器/2.2.2-list.html","title":"2.2.2-list","keywords":"","body":"[TOC] list list的底层是一个双向链表，以结点为单位存放数据，结点的地址在内存中不一定连续，每次插入或删除一个元素，就配置或释放一个元素空间。 list不支持随机存取，适合需要大量的插入和删除，而不关心随即存取的应用场景。 常用函数 list.push_back(elem) //在尾部加入一个数据 list.pop_back() //删除尾部数据 list.push_front(elem) //在头部插入一个数据 list.pop_front() //删除头部数据 list.size() //返回容器中实际数据的个数 list.sort() //排序，默认由小到大 list.unique() //移除数值相同的连续元素 list.back() //取尾部迭代器 list.erase(iterator) //删除一个元素，参数是迭代器，返回的是删除迭代器的下一个位置 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 22:31:00 "},"2-高级/2.2-容器/2.2.3-map.html":{"url":"2-高级/2.2-容器/2.2.3-map.html","title":"2.2.3-map","keywords":"","body":"[TOC] map std::map 是有序键值对容器，它的元素的键是唯一的。用比较函数 Compare 排序键。搜索、移除和插入操作拥有对数复杂度。 map 通常实现为红黑树。 初始化 查找 方法一 std::map m1; T key; ... if(m1.find(key) != m1.end){ //找到了 map[key];//才能访问 } 插入 方法一 数组 ：形如map[key]=value; //map[key] = value map mis; mis[0] = \"first\"; mis[1] = \"second\"; mis[2] = \"third\"; 方法二 pair：形如insert(pair(keyName, valueName); //make_pair map mis2(mis.begin(),mis.end()); mis.insert(pair(3, \"fourth\")); 方法三 make_pair：形如insert(make_pair(key, value)); mapStudent.insert(make_pair(1, \"student_one\")); 方法四 value_type：形如insert(map::value_type(key,value); //value_type mis.insert(map::value_type(3, \"fourth\")); for (auto& pair : mis){ cout 删除 删除所有 方法一 cmap.erase(cmap.begin(), cmap.end()); 方法二 cmap.clear(); map常见问题 1.map[]和find区别 map[]方式访问如果没有对象，便会创建。 find(key)== map.end() 表示没有键值，用于判空。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 22:26:26 "},"2-高级/2.2-容器/2.2.4-set.html":{"url":"2-高级/2.2-容器/2.2.4-set.html","title":"2.2.4-set","keywords":"","body":"set map 、set、multiset、multimap的底层实现都是红黑树 set常用函数 s.begin() // 返回指向第一个元素的迭代器 s.clear() // 清除所有元素 s.count() // 返回某个值元素的个数 s.empty() // 如果集合为空，返回true(真） s.end() // 返回指向最后一个元素之后的迭代器，不是最后一个元素 s.equal_range() // 返回集合中与给定值相等的上下限的两个迭代器 s.erase() // 删除集合中的元素 s.find() // 返回一个指向被查找到元素的迭代器 s.get_allocator() // 返回集合的分配器 s.insert() // 在集合中插入元素 s.lower_bound() // 返回指向大于（或等于）某值的第一个元素的迭代器 s.key_comp() // 返回一个用于元素间值比较的函数 s.max_size() // 返回集合能容纳的元素的最大限值 s.rbegin() // 返回指向集合中最后一个元素的反向迭代器 s.rend() // 返回指向集合中第一个元素的反向迭代器 s.size() // 集合中元素的数目 s.swap() // 交换两个集合变量 s.upper_bound() // 返回大于某个值元素的迭代器 s.value_comp() // 返回一个用于比较元素间的值的函数 set和multiset set不可以插入重复数据，而multiset可以。 set插入数据的同时会返回插入结果，表示插入是否成功。 mutiset不会检测数据，因此可以插入重复数据。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 22:57:02 "},"2-高级/2.2-容器/2.2.5-deque.html":{"url":"2-高级/2.2-容器/2.2.5-deque.html","title":"2.2.5-deque","keywords":"","body":"deque deque是一个双向开口的连续线性空间（双端队列），在头尾两端进行元素的插入跟删除操作都有理想的时间复杂度。 deque的常用函数 deque.push_back(elem) //在尾部加入一个数据。 deque.pop_back() //删除尾部数据。 deque.push_front(elem) //在头部插入一个数据。 deque.pop_front() //删除头部数据。 deque.size() //返回容器中实际数据的个数。 deque.at(idx) //传回索引idx所指的数据，如果idx越界，抛出out_of_range。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 22:41:56 "},"2-高级/2.2-容器/2.2.6-vector、set、list、deque使用场景.html":{"url":"2-高级/2.2-容器/2.2.6-vector、set、list、deque使用场景.html","title":"2.2.6-vector、set、list、deque使用场景","keywords":"","body":"vector、set、list、deque使用场景 vector vector可以随机存储元素（即可以通过公式直接计算出元素地址，而不需要挨个查找），但在非尾部插入删除数据时，效率很低，适合对象简单，对象数量变化不大，随机访问频繁。除非必要，我们尽可能选择使用vector而非deque，因为deque的迭代器比vector迭代器复杂很多。 list list不支持随机存储，适用于对象大，对象数量变化频繁，插入和删除频繁，比如写多读少的场景。 deque 需要从首尾两端进行插入或删除操作的时候需要选择deque。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 22:40:20 "},"2-高级/2.2-容器/2.2.7-hash_map.html":{"url":"2-高级/2.2-容器/2.2.7-hash_map.html","title":"2.2.7-hash_map","keywords":"","body":"hash_map HashMap是基于哈希表实现的，每一个元素是一个key-value对，其内部通过单链表解决冲突问题，容量不足（超过了阀值）时，同样会自动增长。 hashMap使用开链法构建hashTable hash_map和map选择 查找速度 hash_map速度快。 总体来说，hash_map 查找速度会比 map 快，而且查找速度基本和数据数据量大小无关，属于常数级别; 而 map 的查找速度是 log(n) 级别。 数据量 hash_map效率高 如果你考虑效率，特别是在元素达到一定数量级时，考虑考虑 hash_map。 内存空间 hash_map内存空间消耗大 内存使用特别严格，希望程序尽可能少消耗内存，那么一定要小心，hash_map 可能会让你陷入尴尬，特别是当你的 hash_map 对象特别多时，你就更无法控制了。而且 hash_map 的构造速度较慢。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 22:16:14 "},"2-高级/2.2-容器/2.2.8-unordered_map、unordered_set原理.html":{"url":"2-高级/2.2-容器/2.2.8-unordered_map、unordered_set原理.html","title":"2.2.8-unordered_map、unordered_set原理","keywords":"","body":"unordered_map unordered_map的底层是一个防冗余的哈希表（采用除留余数法）。哈希表最大的优点，就是把数据的存储和查找消耗的时间大大降低，时间复杂度为O(1)；而代价仅仅是消耗比较多的内存。 unordered_map 与map的区别？使用场景 构造函数：unordered_map 需要hash函数，等于函数; ​ map只需要比较函数(小于函数). 存储结构：unordered_map 采用hash表存储， ​ map一般采用红黑树(RB Tree) 实现。因此其memory数据结构是不一样的。 总体来说，unordered_map 查找速度会比map快，而且查找速度基本和数据数据量大小，属于常数级别;而map的查找速度是log(n)级别。并不一定常数就比log(n)小，hash还有hash函数的耗时，明白了吧，如果你考虑效率，特别是在元素达到一定数量级时，考虑考虑unordered_map 。但若你对内存使用特别严格，希望程序尽可能少消耗内存，那么一定要小心，unordered_map 可能会让你陷入尴尬，特别是当你的unordered_map 对象特别多时，你就更无法控制了，而且unordered_map 的构造速度较慢。 unordered_set unordered_map、unordered_set的常用函数 unordered_map.begin() 　　 //返回指向容器起始位置的迭代器（iterator） unordered_map.end() 　　 //返回指向容器末尾位置的迭代器 unordered_map.cbegin()　 //返回指向容器起始位置的常迭代器（const_iterator） unordered_map.cend() 　　 //返回指向容器末尾位置的常迭代器 unordered_map.size() 　　 //返回有效元素个数 unordered_map.insert(key) //插入元素 unordered_map.find(key) 　 //查找元素，返回迭代器 unordered_map.count(key) 　 //返回匹配给定主键的元素的个数 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 22:48:38 "},"2-高级/2.3-时间库/":{"url":"2-高级/2.3-时间库/","title":"2.3-时间库","keywords":"","body":"2.3-时间库 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-03-02 22:55:40 "},"2-高级/2.3-时间日期本地化库/":{"url":"2-高级/2.3-时间日期本地化库/","title":"2.3-时间日期本地化库","keywords":"","body":"# chrono库 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 22:58:24 "},"2-高级/2.3-时间日期本地化库/2.3.1-常用功能.html":{"url":"2-高级/2.3-时间日期本地化库/2.3.1-常用功能.html","title":"2.3.1-常用功能","keywords":"","body":"常用功能 睡眠 #include #include void main(){ std::this_thread::sleep_for(std::chrono:: milliseconds (1000)); //休眠1000毫秒 } 获得当前程序运行毫秒 #include void main(){ int tick=(int)(std::clock()*1000/ CLOCKS_PER_SEC); } 计时 #include #include void main(){ auto start = high_resolution_clock::now(); std::this_thread::sleep_for(std::chrono:: milliseconds (2000)); auto end = high_resolution_clock::now(); duration_cast(end - start).count(); } Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 22:58:38 "},"2-高级/2.4-算法库/":{"url":"2-高级/2.4-算法库/","title":"2.4-算法库","keywords":"","body":"Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-26 02:37:02 "},"2-高级/2.5-内存管理/2.5.1-深拷贝和浅拷贝.html":{"url":"2-高级/2.5-内存管理/2.5.1-深拷贝和浅拷贝.html","title":"2.5.1-深拷贝和浅拷贝","keywords":"","body":"深拷贝和浅拷贝 浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享一块内存； 深拷贝会创造一个相同的对象，新对象与原对象不共享内存，修改新对象不会影响原对象。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 00:58:20 "},"2-高级/2.5-内存管理/2.5.2-左值引用和右值引用.html":{"url":"2-高级/2.5-内存管理/2.5.2-左值引用和右值引用.html","title":"2.5.2-左值引用和右值引用","keywords":"","body":"引用和右值引用 C++对于左值和右值没有标准定义，但是有一个被广泛认同的说法： 可以取地址的，有名字的，非临时的就是左值； 不能取地址的，没有名字的，临时的就是右值； 右值引用 c++ 11 特性 类型 && 引用名 = 右值表达式; int &&var = 10; 右值引用的存在并不是为了取代左值引用，而是充分利用右值(特别是临时对象)的构造来减少对象构造和析构操作以达到提高效率的目的。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 11:36:04 "},"2-高级/2.5-内存管理/2.5.3-拷贝构造和赋值操作符重载.html":{"url":"2-高级/2.5-内存管理/2.5.3-拷贝构造和赋值操作符重载.html","title":"2.5.3-拷贝构造和赋值操作符重载","keywords":"","body":"拷贝构造函数和赋值运算符重载区别 拷贝构造函数用于构造新的对象 Student s; Student s1 = s; // 隐式调用拷贝构造函数 Student s2(s); // 显式调用拷贝构造函数 赋值运算符重载用于将源对象的内容拷贝到目标对象中，而且若源对象中包含未释放的内存需要先将其释放 Student s; Student s1; s1 = s; // 使用赋值运算符 一般情况下，类中包含指针变量时需要重载拷贝构造函数、赋值运算符和析构函数。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 16:12:18 "},"2-高级/2.5-内存管理/2.5.4-字节对齐.html":{"url":"2-高级/2.5-内存管理/2.5.4-字节对齐.html","title":"2.5.4-字节对齐","keywords":"","body":"字节对齐基本原则 结构体内最大长度的变量为一次访问长度 结构体对齐 关键字#programma Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 16:13:00 "},"2-高级/2.5-内存管理/2.5.5-内存分配的几种方式.html":{"url":"2-高级/2.5-内存管理/2.5.5-内存分配的几种方式.html","title":"2.5.5-内存分配的几种方式","keywords":"","body":"内存分配的几种方式 1.栈上分配 在执行函数时，局部变量的内存都可以在栈上分配，函数结束时会自动释放；栈内存的分配运算内置于处理器的指令集中，效率很高，但分配的内存容量有限 2.堆上分配 就是那些由malloc分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般malloc就要对应一个 free。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收 3.自由存储区 从自由存储区分配：如果说堆是操作系统维护的一块内存，那么自由存储区就是C++中通过new和delete动态分配和释放对象的抽象概念。需要注意的是，自由存储区和堆比较像，但不等价。 c++的new 一般在自由存储区，自由存储区是抽象层，看平台的实现，有的平台是用堆实现，有的不是。 4.常量存储区 从常量存储区分配：特殊的存储区，存放的是常量，不可修改； 5.全局/静态存储区 从全局/静态存储区分配：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量和静态变量又分为初始化的和未初始化的，在C++里面没有这个区分了，它们共同占用同一块内存区，在该区定义的变量若没有初始化，则会被自动初始化，例如int型变量自动初始为0 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 16:10:40 "},"2-高级/2.6-智能指针/":{"url":"2-高级/2.6-智能指针/","title":"2.6-智能指针","keywords":"","body":"智能指针 为了更加容易（更加安全）的使用动态内存，引入了智能指针的概念。智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。 智能指针是一个RAII类模型，用于动态分配内存，其设计思想是将基本类型指针封装为（模板）类对象指针，并在离开作用域时调用析构函数，使用delete删除指针所指向的内存空间。 分为以下几种： auto_ptr、unique_ptr、shared_ptr和weak_ptr auto_ptr 实现独占式拥有的概念，同一时间只能有一个智能指针可以指向该对象。 但auto_ptr在C++11中被摒弃，其主要问题在于： 对象所有权的转移，比如在函数传参过程中，对象所有权不会返还，从而存在潜在的内存崩溃问题； 不能指向数组，也不能作为STL容器的成员。 unique_ptr 实现独占式拥有的概念，同一时间只能有一个智能指针可以指向该对象。 因为无法进行拷贝构造和拷贝赋值，但是可以进行移动构造和移动赋值； shared_ptr 实现共享式拥有的概念，即多个智能指针可以指向相同的对象，该对象及相关资源会在其所指对象不再使用之后，自动释放与对象相关的资源； weak_ptr 解决shared_ptr相互引用时，两个指针的引用计数永远不会下降为0，从而导致死锁问题。而weak_ptr是对对象的一种弱引用，可以绑定到shared_ptr，但不会增加对象的引用计数。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 11:59:10 "},"2-高级/2.7-常用知识/2.7.1-类型转换.html":{"url":"2-高级/2.7-常用知识/2.7.1-类型转换.html","title":"2.7.1-类型转换","keywords":"","body":"类型转换 为什么不使用C的强制转换？ C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。 类型 参数对象类型 特点 static_cast 基本数据类型、子类向父类的安全转换、void*和其他类型指针。 向下转化不安全。 const_cast 使用const或volatile修饰符的变量。 去掉const属性 dynamic_cast 对象的类层次间的向上和向下转化 向下转化安全，有类型检查 reinterpret_cast 不同类型指针之间、不同类型引用之间、指针和能容纳指针的整数类型 什么都能转，但少用。 static_cast 用于基本数据类型之间的转换、子类向父类的安全转换、void*和其他类型指针之间的转换。 比如非const转const，void*转指针等, static_cast能用于多态向上转化，如果向下转能成功但是不安全，结果未知； const_cast 用于去除const或volatile属性； dynamic_cast 用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。 因为编译器默认向上转换总是安全的，而向下转换时，dynamic_cast具有类型检查的功能； dynamic_cast转换失败时，对于指针会返回目标类型的nullptr，对于引用会返回bad_cast异常； 向上转换：指的是子类向基类的转换 向下转换：指的是基类向子类的转换 reinterpret_cast 用于不同类型指针之间、不同类型引用之间、指针和能容纳指针的整数类型之间的转换。 几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用； Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 16:21:04 "},"2-高级/2.7-常用知识/2.7.2-动态链接和静态链接.html":{"url":"2-高级/2.7-常用知识/2.7.2-动态链接和静态链接.html","title":"2.7.2-动态链接和静态链接","keywords":"","body":"静态链接 静态链接：是在编译链接时直接将需要的执行代码拷贝到调用处； 优点：在于程序在发布时不需要依赖库，可以独立执行，、 缺点：在于程序的 体积会相对较大，而且如果静态库更新之后，所有可执行文件需要重新链接； 动态链接 动态链接：是在编译时不直接拷贝执行代码，而是通过记录一系列符号和参数，在程序运行或加载时将这些信息传递给操作系统，操作系统负责将需要的动态库加载到内存中，然后程序在运行到指定代码时，在共享执行内存中寻找已经加载的动态库可执行代码，实现运行时链接； 优点：在于多个程序可以共享同一个动态库，节省资源； 缺点：在于由于运行时加载，可能影响程序的前期执行性能。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 11:17:06 "},"2-高级/2.7-常用知识/2.7.3-main函数.html":{"url":"2-高级/2.7-常用知识/2.7.3-main函数.html","title":"2.7.3-main函数","keywords":"","body":"main函数 main函数执行之前进行的操作 设置栈指针； 初始化static静态和global全局变量，即data段的内容； 将未初始化部分的赋初值：数值型short，int，long等为0，bool为FALSE，指针为NULL； 将main函数的参数，argc，argv等传递给main函数，然后才真正运行main函数。 graph TB A(栈指针)-->B(初始化data段内容); B-->C(未初始化部分赋初值); C-->D(传递参数到Main); Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 12:29:58 "},"2-高级/2.7-常用知识/2.7.5-static_assert静态断言.html":{"url":"2-高级/2.7-常用知识/2.7.5-static_assert静态断言.html","title":"2.7.5-static_assert静态断言","keywords":"","body":"Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-03-02 13:50:22 "},"2-高级/2.8-模板/2.8.1-模板类和类模板.html":{"url":"2-高级/2.8-模板/2.8.1-模板类和类模板.html","title":"2.8.1-模板类和类模板","keywords":"","body":"类模板和模板类 类模板 ：通过模板实现的通用类，本质是个模板。 模板类：模板类是类模板实例化后的一个产物,就是传入泛型之后最终生成的类。本质是个类 例如： 类模板： template class 类名{ 类成员声明 }; 模板类： //有一个类模板 template class ClassA{ T getNum(); }; ClassA A;//已经实例化了，确定泛型参数为int 生成的类就是下面的 //这个就是生成的模板类 class ClassA{ int getNum(); }; Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 11:05:30 "},"2-高级/2.8-模板/2.8.2-模板函数和模板的特化.html":{"url":"2-高级/2.8-模板/2.8.2-模板函数和模板的特化.html","title":"2.8.2-模板函数和模板的特化","keywords":"","body":"模板函数和模板类的特例化 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 16:56:20 "},"2-高级/2.9-c++异常机制/":{"url":"2-高级/2.9-c++异常机制/","title":"2.9-c++异常机制","keywords":"","body":"纯虚函数 定义纯虚函数是为了实现一个接口，起到规范的作用，想要继承这个类就必须覆盖该函数。 实现方式是在虚函数声明的结尾加上= 0即可。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 13:30:20 "},"3-网络/":{"url":"3-网络/","title":"3-网络","keywords":"","body":"常见的网络知识 网络层次划分 TCP/IP 五层模型 应用层 （传递报文） 传输层 （传递分组） 网络层（传递IP数据包） 数据链路层（传递帧） 物理层（传递二进制码流） OSI七层网络模型 应用层 表示层 会话层 传输层 网络层 数据链路层 梳理曾 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-03-01 00:52:54 "},"3-网络/3.1-TCP/":{"url":"3-网络/3.1-TCP/","title":"3.1-TCP","keywords":"","body":"TCP 传输控制协议（TCP，Transmission Control Protocol），工作在传输层。 以字节流为传输单位。 特点 1.面向连接的通信协议 通过三次握手建立连接，通讯完成时通过四次挥手拆除连接。 2.可靠的数据流服务 TCP 连接传送的数据，无差错、不丢失、不重复，并且按序到达。 采用\"带重传的肯定确认\"技术来实现传输的可靠性。 TCP还采用一种称为\"滑动窗口\"的方式进行流量控制，所谓窗口实际表示接收能力，用以限制发送方的发送速度 3.端对端传输 4.面向字节流传输 虽然应用程序和 TCP 的交互式一次一个数据块(大小不等)，但 TCP 把应用程序交下来的数据仅仅看成是一连串的`无结构的字节流。 5.全双工 两端可以同时传输数据、和接收数据 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-03-01 18:08:26 "},"3-网络/3.1-TCP/3.1.1-TCP三次握手.html":{"url":"3-网络/3.1-TCP/3.1.1-TCP三次握手.html","title":"3.1.1-TCP三次握手","keywords":"","body":"[TOC] TCP的三次握手 TCP开始传输时 需要建立连接，建立连接过程中会进行三次数据传输。 目的 1.测试传输双方: 发送数据能力 接受数据能力 2.指定自己的初始化序列号，为后面的可靠传送做准备。 过程 刚开始客户端处于 CLOSED 的状态，服务端处于LISTEN状态 第一次握手：客户端发送一个SYN 报文，并指明客户端的初始化序列号 ISN(c) 此时客户端处于 SYN_Send 状态，服务端收到了。就能得出结论： >客户端的发送能力、服务端的接收能力是正常的。 第二次握手：服务端收到SYN 报文之后，自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_RCVD 的状态。客户端收到了。就能得出结论： 服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。 第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。就能得出结论： 客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。 服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方以建立起了链接 时序图 sequenceDiagram Note left of 客户端: CLOSED Note right of 服务器: LISTEN 客户端 -->> 服务器 : 发送一个SYN 报文 Note left of 客户端 : SYN_Send 服务器 -->> 客户端 : 应答一个 SYN+ACK 报文 Note right of 服务器: SYN_RCVD Note left of 客户端 : ESTABLISHED 客户端 -->> 服务器 :会回应一个 ACK 报文 Note right of 服务器: ESTABLISHED Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-03-01 00:14:36 "},"3-网络/3.1-TCP/3.1.2-TCP四次挥手.html":{"url":"3-网络/3.1-TCP/3.1.2-TCP四次挥手.html","title":"3.1.2-TCP四次挥手","keywords":"","body":"[TOC] TCP四次挥手 TCP结束传输时 需要断开连接，断开连接过程中会进行四次数据传输。 目的 断开双方的连接。 前两次挥手用于断开一个向的连接，后两次挥手用于断开另一方向的连接。 过程 刚开始双方都处于 Establised 状态，假如是客户端先发起关闭请求， 第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于FIN_WAIT1状态。 第二次握手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT2状态。 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态 服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。 时序图 sequenceDiagram Note left of 客户端: ESTABLISHED Note left of 客户端: 主动关闭 Note right of 服务器: ESTABLISHED 客户端 -->> 服务器 : 发送一个FIN 报文，报文中会指定一个序列号M Note left of 客户端 : FIN_WAIT1 服务器 -->> 客户端 : 应答一个 ACK 报文,报文指定序列号M+1 Note right of 服务器: CLOSE_WAIT2 服务器 -->> 客户端 : 发给 FIN 报文 Note right of 服务器: LAST_ACK Note left of 客户端 : Established 客户端 -->> 服务器 : 发送一个 ACK 报文作为应答,报文指定序列号N+1 Note right of 服务器: Established Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-03-01 00:14:48 "},"3-网络/3.1-TCP/3.1.3-状态码.html":{"url":"3-网络/3.1-TCP/3.1.3-状态码.html","title":"3.1.3-状态码","keywords":"","body":"常用状态含义 LISTEN – 侦听来自远方TCP端口的连接请求； SYN-SENT -在发送连接请求后等待匹配的连接请求； SYN-RECEIVED – 在收到和发送一个连接请求后等待对连接请求的确认； ESTABLISHED- 代表一个打开的连接，数据可以传送给用户； FIN-WAIT-1 – 等待远程TCP的连接中断请求，或先前的连接中断请求的确认； FIN-WAIT-2 – 从远程TCP等待连接中断请求； CLOSE-WAIT – 等待从本地用户发来的连接中断请求； CLOSING -等待远程TCP对连接中断的确认； LAST-ACK – 等待原来发向远程TCP的连接中断请求的确认； TIME-WAIT -等待足够的时间以确保远程TCP接收到连接中断请求的确认； CLOSED – 没有任何连接状态； Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-03-01 00:13:30 "},"3-网络/3.1-TCP和UDP/":{"url":"3-网络/3.1-TCP和UDP/","title":"3.1-TCP和UDP","keywords":"","body":"3.1-TCP和UDP Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-03-02 22:55:40 "},"3-网络/3.1-TCP和UDP/3.1.1-TCP三次握手.html":{"url":"3-网络/3.1-TCP和UDP/3.1.1-TCP三次握手.html","title":"3.1.1-TCP三次握手","keywords":"","body":"3.1.1-TCP三次握手 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-03-02 22:55:40 "},"3-网络/3.1-TCP和UDP/3.1.2-TCP四次挥手.html":{"url":"3-网络/3.1-TCP和UDP/3.1.2-TCP四次挥手.html","title":"3.1.2-TCP四次挥手","keywords":"","body":"3.1.2-TCP四次挥手 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-03-02 22:55:40 "},"3-网络/3.2-socket/":{"url":"3-网络/3.2-socket/","title":"3.2-socket","keywords":"","body":"3.2-socket Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-03-02 22:55:40 "},"3-网络/3.2-socket/3.2.1-socket组成.html":{"url":"3-网络/3.2-socket/3.2.1-socket组成.html","title":"3.2.1-socket组成","keywords":"","body":"3.2.1-socket组成 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-03-02 22:55:40 "},"3-网络/3.2-UDP/":{"url":"3-网络/3.2-UDP/","title":"3.2-UDP","keywords":"","body":"UDP UDP(User Datagram Protocol)传输协议，工作在传输层。 数据包为传输单位。 特点 1.面向消息的传输层协议 2.不可靠传输 ​ 没有流控制，没有应答确认机制，不能解决丢包、重发、错序问题。 3.无连接 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-03-01 00:52:46 "},"3-网络/3.4-socket/":{"url":"3-网络/3.4-socket/","title":"3.4-socket","keywords":"","body":"socket简介 套接字协议 类型 流式套接字（SOCK_STREAM），数据报套接字（SOCK_DGRAM）及原始套接字。 1．流式套接字（SOCK_STREAM） 流式的套接字可以提供可靠的、面向连接的通讯流。如果你通过流式套接字发送了顺序的数据：“1”、“2”。那么数据到达远程时候的顺序也是“1”、“2”。 流式套接字使用了TCP（Transmission Control Protocol）协议，保证数据传输是正确的，并且是顺序的。 2．数据报套接字（SOCK_DGRAM） 数据报套接字定义了一种无连接的服务，数据通过相互独立的报文进行传输，是无序的，并且不保证可靠，无差错。 数据报套接字使用使用者数据报协议UDP（User Datagram Protocol）协议。 3．原始套接字 原始套接字主要用于一些协议的开发，可以进行比较底层的操作。它功能强大，但是没有上面介绍的两种套接字使用方便，一般的程序也涉及不到原始套接字。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-03-01 00:46:50 "},"3-网络/3.4-socket/3.4.1-socket组成.html":{"url":"3-网络/3.4-socket/3.4.1-socket组成.html","title":"3.4.1-socket组成","keywords":"","body":"socket组成 struct socket { socket_state state; unsigned long flags; const struct proto_ops *ops; struct fasync_struct *fasync_list; struct file *file; struct sock *sk; wait_queue_head_t wait; short type; }; Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-03-01 22:42:30 "},"3-网络/3.4-socket/3.4.2-setsocketopt常用设置.html":{"url":"3-网络/3.4-socket/3.4.2-setsocketopt常用设置.html","title":"3.4.2-setsocketopt常用设置","keywords":"","body":"Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-03-02 12:10:06 "},"3-网络/3.4-socket/3.4.3-socket基本思路.html":{"url":"3-网络/3.4-socket/3.4.3-socket基本思路.html","title":"3.4.3-socket基本思路","keywords":"","body":"[TOC] Socket编程基本思路 TCP 服务端 1、初始化Windows Socket库。 2、创建Socket。 3、绑定Socket。 4、监听。 5、Accept。 6、接收、发送数据 客户端 1、初始化Windows Socket库。 2、创建Socket。 3、连接Socket。 4、接收、发送数据。 UDP 发送端 建立udpsocket服务 提供数据，并且将数据封装到包中 关闭Socket服务的发送功能，将数据包发送出去 关闭资源 接收端 建立udpsocket服务 定义一个空数据包，用于存储接收到的字节数据。 通过Socket服务的receive（）方法将受到的数据存储到已经定义好的空数据包中 取出不同的数据 关闭资源 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-03-01 19:08:46 "},"3-网络/3.3-网络编程常见的模型.html":{"url":"3-网络/3.3-网络编程常见的模型.html","title":"3.3-网络编程常见的模型","keywords":"","body":"[TOC] 网络编程常见的模型 Linux平台 参考 网络编程概述 阻塞I/O 非阻塞I/O I/O多路复用 select模型 poll模型 epoll模型 select/poll/epoll比较 信号驱动I/O（SIGIO） 异步I/O Windows平台 select模型 含义 对多个socket 进行管理 调用select()可以获取指定socket状态,即select 选择获得有响应的指定的socket 目的 解决基本C/S模型中，accept()、recv()、send()阻塞的问题 select模型与C/S模型的不同点 C/S模型中accept()会阻塞一直等待socket来连接 select模型只解决accept()傻等的问题，不解决recv(),send()执行阻塞问题 在应用程序使用select函数时会发生阻塞现象。可以通过select的timeout参数设置阻塞的时间。在设置的时间内，select函数等待，直到一个或多个套接字满足可读或可写的条件。 用法 服务端 1.一般创建非阻塞步骤（初始化，创建，绑定ip和端口，监听，ioctlsocket设置非阻塞） 2.装填socket数组 FD_SET(socketServer, &allSockets); 3.调用select()等待，返回有响应的socket，对有响应的socket 做相应处理(accept,send,recv) WSAAsyncSelect模型 含义 应用程序可以在一个socket上接收以windows消息为基础的网络事件通知，它实现了读写数据的异步通知功能，但不提供异步的数据传输。 目的 解决select模型 调用select()会阻塞的问题。 与select模型的区别 WSAAsyncSelect是非阻塞的。Windows sockets程序在调用recv或send之前，调用WSAAsyncSelect注册网络事件。WSAAsyncSelect函数立即返回。当系统中数据准备好时，会向应用程序发送消息。此此消息的处理函数中可以调用recv或send进行接收或发送数据。 用法 1.初始化socket环境，并创建win32自定义事件的socket事件 WM_SOCKET 2.调用WSAAsyncSelect()绑定事件到窗口消息队列 3.通过GetMessage()轮询消息，当消息事件发生时，实现对socket的处理(包括accept,send,recv) WSAEventSelect模型 含义 允许在多个Socket上接收以事件为基础的网络事件通知，应用程序在创建Socket后，调用WSAEventSelect()函数将事件对象与网络事件集合相关联。当网络事件发生时，应用程序以事件的形式接收网络事件通知。 目的 与WSAAsyncSelect、select模型的区别 Select：程序员主动调用select函数，获取指定socket状态， WSAEventSelect，WSAAsyncSelect：被动地选择系统通知应用程序socket状态变化。 WSAEventSelect，WSAAsyncSelect不同之处：在于socket事件的通知方法，WSAAsyncSelec模型利用窗口句柄和消息映射函数通知网络事件，而WSAEventSelect模型利用WSAEVENT通知网络事件。 用法 重叠I/O模型 含义 重叠模型是让应用程序使用重叠数据结构(WSAOVERLAPPED)，一次投递一个或多个Winsock I/O请求。针对这些提交的请求，在它们完成之后，应用程序会收到通知，于是就可以通过自己另外的代码来处理这些数据了。 重叠i/o是真正意义上的异步io模型 调用输入/输出函数后 立即返回（WSARecv,WSASend)。 目的 区别 1.可以运行在支持Winsock2的所有Windows平台 ,而不像完成端口只是支持NT系统。 2.比起阻塞、select、WSAAsyncSelect以及WSAEventSelect等模型，重叠I/O(Overlapped I/O)模型使应用程序能达到更佳的系统性能。 因为它和这4种模型不同的是，使用重叠模型的应用程序通知缓冲区收发系统直接使用数据，也就是说，如果应用程序投递了一个10KB大小的缓冲区来接收数据，且数据已经到达套接字，则该数据将直接被拷贝到投递的缓冲区。不需要等待调用recv时才拷贝 而这4种模型种，数据到达并拷贝到单套接字接收缓冲区中，此时应用程序会被告知可以读入的容量。当应用程序调用接收函数之后，数据才从单套接字缓冲区拷贝到应用程序的缓冲区，差别就体现出来了。 完成端口模型 含义 利用线程池处理异步I/O请求，利用完成端口模型可以管理成百上千Socket。 可以把完成端口看成系统维护的一个队列，操作系统把重叠I／O操作完成的事件通知放到该队列中，因此称其为“完成”端口，当Socket被创建后，可以将其与一个完成端口联系起来。 一个应用程序可以创建多个工作线程用于处理完成端口上的通知事件，通常应该为每个CPU创建一个线程。 一个完成端口实际就是一个通知队列,操作系统把已经完成的重叠I/O请求的通知放到队列中,当某项IO操作完成后,系统会向服务端完成端口发送一个i/o完成数据包,此操作在系统内部完成,应用程序在收到I/o完成数据包后,完成端口队列的一个线程被唤醒,为客户端提供服务,服务完成后,该线程会继续在完成端口上等待. 目的 (1) 首先，如果使用“同步”的方式来通信的话，这里说的同步的方式就是说所有的操作都在一个线程内顺序执行完成，这么做缺点是很明显的：因为同步的通信操作会阻塞住来自同一个线程的任何其他操作，只有这个操作完成了之后，后续的操作才可以完成；一个最明显的例子就是咱们在MFC的界面代码中，直接使用阻塞Socket调用的代码，整个界面都会因此而阻塞住没有响应！所以我们不得不为每一个通信的Socket都要建立一个线程，多麻烦？这不坑爹呢么？所以要写高性能的服务器程序，要求通信一定要是异步的。 (2) 各位读者肯定知道，可以使用使用“同步通信(阻塞通信)+多线程”的方式来改善(1)的情况，那么好，想一下，我们好不容易实现了让服务器端在每一个客户端连入之后，都要启动一个新的Thread和客户端进行通信，有多少个客户端，就需要启动多少个线程，对吧；但是由于这些线程都是处于运行状态，所以系统不得不在所有可运行的线程之间进行上下文的切换，我们自己是没啥感觉，但是CPU却痛苦不堪了，因为线程切换是相当浪费CPU时间的，如果客户端的连入线程过多，这就会弄得CPU都忙着去切换线程了，根本没有多少时间去执行线程体了，所以效率是非常低下的，承认坑爹了不？ (3) 而微软提出完成端口模型的初衷，就是为了解决这种\"one-thread-per-client\"的缺点的，它充分利用内核对象的调度，只使用少量的几个线程来处理和客户端的所有通信，消除了无谓的线程上下文切换，最大限度的提高了网络通信的性能， 区别 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-03-02 22:53:36 "},"4-多线程/":{"url":"4-多线程/","title":"4-多线程","keywords":"","body":"1.介绍 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-26 02:37:02 "},"4-多线程/4.1-线程/":{"url":"4-多线程/4.1-线程/","title":"4.1-线程","keywords":"","body":"线程 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-27 23:10:10 "},"5-算法/":{"url":"5-算法/","title":"5-算法","keywords":"","body":"主要以Leetcode题目为主 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-03-02 17:17:12 "},"5-算法/5-15-并查集/":{"url":"5-算法/5-15-并查集/","title":"5-15-并查集","keywords":"","body":"1.介绍 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-26 02:37:02 "},"5-算法/5-16-宏定义/5.16.1-使用宏定义计算一年多少秒.html":{"url":"5-算法/5-16-宏定义/5.16.1-使用宏定义计算一年多少秒.html","title":"5.16.1-使用宏定义计算一年多少秒","keywords":"","body":"写个宏定义一年有多少秒 标答 考虑闰年 闰年两种情况： 非世纪年能被4整除，且不能被100整除的是闰年。（如2004年是闰年，1901年不是闰年） 世纪年能被400整除的是闰年。（如2000年是闰年，1900年不是闰年） define Seconds_Of_Year(year) { (((( (year % 4==0) && (year % 100 != 0 )) || (year % 400==0)) ? 1 : 0 )+365) 24 3600 } 不考虑闰年 注意：UL表示长整型 考细节 define S (60 60 24 * 365UL) Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-03-02 12:08:42 "},"5-算法/5.1-数组/":{"url":"5-算法/5.1-数组/","title":"5.1-数组","keywords":"","body":"数组 常见问题分类： 搜索遍历 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-03-02 17:29:10 "},"5-算法/5.1-数组/5.1.1_26_删除有序数组中的重复项.html":{"url":"5-算法/5.1-数组/5.1.1_26_删除有序数组中的重复项.html","title":"5.1.126删除有序数组中的重复项","keywords":"","body":"[TOC] 删除有序数组中的重复项 https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/ 输入 升序排列 的数组 原地 删除重复出现的元素 每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 输出 去除了重复项的数组 数组的新长度 示例 示例1 输入：nums = [1,1,2] 输出：2, nums = [1,2,_] 示例2 输入：nums = [0,0,1,1,1,2,2,3,3,4] 输出：5, nums = [0,1,2,3,4] 方法 方法1 思路 使用两个指针slow、fast分别记录，新数组当前位置，和旧数组当前位置。 出口： fast >= array.length; 判断条件： array[slow] nums[slow + 1] = nums[fast]; slow++; fast++, array[slow] == array[fast]时 fast++; 代码 class Solution { public: //正解1 static int removeDuplicates(std::vector nums) { int slow = 0; int fast = 0; while (fast Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-03-02 14:13:48 "},"5-算法/5.1-数组/5.1.1_370.html":{"url":"5-算法/5.1-数组/5.1.1_370.html","title":"5.1.1_370","keywords":"","body":"5.1.1_370 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-03-02 22:55:40 "},"5-算法/5.1-数组/5.1.1_531.html":{"url":"5-算法/5.1-数组/5.1.1_531.html","title":"5.1.1_531","keywords":"","body":"5.1.1_531 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-03-02 22:55:40 "},"5-算法/5.1-数组/5.1.2_370_区间加法.html":{"url":"5-算法/5.1-数组/5.1.2_370_区间加法.html","title":"5.1.2370区间加法","keywords":"","body":"[TOC] 区间加法 https://leetcode-cn.com/problems/range-addition 输入 初始化为0、长度为n的数组arr k个三元组updates【k】【startIndex,endIndex,Inc】 代表k次操作，一次操作表示将arr的【startIndex,endIndex】范围内的数值 +Inc； 输出 返回k次操作后的数组 示例 示例1 输入: length = 5, updates = [[1,3,2],[2,4,3],[0,2,-2]] 输出: [-2,0,3,5,3] 解释: 初始状态:[0,0,0,0,0] 进行了操作〔1,3,2]后的状态:[0,2,2,2,0] 进行了操作〔[2,4,3]后的状态:[0,2,5,5,3] 进行了操作〔[0,2,-2]后的状态:[-2,0,3,5,3] 方法 方法1 差分数组 差分数组：类似于求解前缀和，给出原数组为d，差分数组为f，那么有f[i] = d[i] - d[i - 1] 差分数组主要支持两种操作：1、区间修改；2、单点查询 思路 给每个操作的arr[start]加inc，和arr[end+1]减Inc; 利用差分数组：f[i] = arr[i] + arr[i-1] 在[1,length-1]区间，进行构建差分数组。 总结： 把每个操作的start位置要增加的统一增加上，同时每个操作的end+1的位置减掉（因为后面差分数组构建时会增加。） 代码 class Solution { public: //正解1 时间复杂度O(n) static std::vector getModifiedArray( int length, std::vector> updates) { std::vector arr(length, 0); for (size_t i = 0; i getModifiedArray2( int length, std::vector> updates) { std::vector arr(length, 0); for (size_t i = 0; i Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-03-02 17:14:24 "},"5-算法/5.1-数组/5.1.3_531_孤独像素I.html":{"url":"5-算法/5.1-数组/5.1.3_531_孤独像素I.html","title":"5.1.3531孤独像素I","keywords":"","body":"[TOC] 孤独像素 I https://leetcode-cn.com/problems/lonely-pixel-i/ 输入 给你一个大小为 m * n 的图像 picture ，图像由黑白像素组成，'B' 表示黑色像素，'W' 表示白色像素， 黑色孤独像素 的定义为： 如果黑色像素 'B' 所在的同一行和同一列不存在其他黑色像素，那么这个黑色像素就是黑色孤独像素。 输出 请你统计并返回图像中 黑色 孤独像素的数量。 示例 示例1 picture = [ [\"W\",\"W\",\"B\"], [\"W\",\"B\",\"W\"], [\"B\",\"W\",\"W\"] ] 输入：picture = [[\"W\",\"W\",\"B\"],[\"W\",\"B\",\"W\"],[\"B\",\"W\",\"W\"]] 输出：3 解释：全部三个 'B' 都是黑色的孤独像素 示例2 picture = [ [\"B\",\"B\",\"B\"], [\"B\",\"B\",\"W\"], [\"B\",\"B\",\"B\"] ] 输入：picture = [[\"B\",\"B\",\"B\"],[\"B\",\"B\",\"W\"],[\"B\",\"B\",\"B\"]] 输出：0 方法 方法1 暴力法 思路 步骤： 遍历每一个黑色像素。 再根据当前像素行列，判断是否行和列都仅有一个黑色像素。是则黑色孤独像素，否则非。 判断条件： 如果有白色像素，必然不是黑色孤独像素，故当前像素是黑色像素才可进行黑色孤独像素判断。 当且仅当 当前黑色像素的行列都只有一个黑色像素时，此时是一个黑色孤独像素。 代码 class Solution { public: //暴力法 时间复杂度O(raw*col*(raw+col)) static int findLonelyPixel(std::vector>& picture) { int raws = picture.size(); int cols = picture[0].size(); int counts = 0; for (size_t i = 0; i 方法2 预处理法 思路 在暴力遍历时，会有步骤1遍历一次黑色像素，步骤2 循环内又遍历了一次黑色像素。就是n*n次循环了。 所以改良方法就是在步骤1的遍历一遍，把每个行、列的黑色像素数量保存一份，在出循环，再遍历一次。 步骤： 遍历黑色像素，记录行、列的黑色像素数量。 再遍历一次，当前像素为 黑色像素 且 其行数组和列数组的黑色像素数量为1。 判断条件： 当前像素为 黑色像素 且 其行黑色像素数量和列黑色像素数量的数量为1。 代码 class Solution { public: //预处理法 O(raw*col) static int findLonelyPixel(std::vector>& picture) { int counts = 0; int raws = picture.size(); int cols = picture[0].size(); int max = raws > cols?raws:cols; std::vector rawValue(max, 0); std::vector colValue(max, 0); for (size_t i = 0; i Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-03-02 22:13:12 "},"5-算法/5.10-深搜/":{"url":"5-算法/5.10-深搜/","title":"5.10-深搜","keywords":"","body":"1.介绍 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-26 02:37:02 "},"5-算法/5.11-广搜/":{"url":"5-算法/5.11-广搜/","title":"5.11-广搜","keywords":"","body":"1.介绍 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-26 02:37:02 "},"5-算法/5.12-贪心/":{"url":"5-算法/5.12-贪心/","title":"5.12-贪心","keywords":"","body":"1.介绍 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-26 02:37:02 "},"5-算法/5.13-动态规划/":{"url":"5-算法/5.13-动态规划/","title":"5.13-动态规划","keywords":"","body":"1.介绍 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-26 02:37:02 "},"5-算法/5.13-动态规划/5.13.1-651.html":{"url":"5-算法/5.13-动态规划/5.13.1-651.html","title":"5.13.1-651","keywords":"","body":"Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-26 02:37:02 "},"5-算法/5.13-动态规划/5.13.2-750.html":{"url":"5-算法/5.13-动态规划/5.13.2-750.html","title":"5.13.2-750","keywords":"","body":"Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-26 02:37:02 "},"5-算法/5.13-动态规划/5.13.3-1055.html":{"url":"5-算法/5.13-动态规划/5.13.3-1055.html","title":"5.13.3-1055","keywords":"","body":"Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-26 02:37:02 "},"5-算法/5.14-双指针/":{"url":"5-算法/5.14-双指针/","title":"5.14-双指针","keywords":"","body":"1.介绍 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-26 02:37:02 "},"5-算法/5.16-滑动窗口/":{"url":"5-算法/5.16-滑动窗口/","title":"5.16-滑动窗口","keywords":"","body":"1.介绍 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-26 02:37:02 "},"5-算法/5.2-字符串/":{"url":"5-算法/5.2-字符串/","title":"5.2-字符串","keywords":"","body":"1.介绍 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-26 02:37:02 "},"5-算法/5.2-字符串/5.2.1-536.html":{"url":"5-算法/5.2-字符串/5.2.1-536.html","title":"5.2.1-536","keywords":"","body":"Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-26 02:37:02 "},"5-算法/5.2-字符串/5.2.2-544.html":{"url":"5-算法/5.2-字符串/5.2.2-544.html","title":"5.2.2-544","keywords":"","body":"Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-26 02:37:02 "},"5-算法/5.3-递归/":{"url":"5-算法/5.3-递归/","title":"5.3-递归","keywords":"","body":"1.介绍 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-26 02:37:02 "},"5-算法/5.4-栈/":{"url":"5-算法/5.4-栈/","title":"5.4-栈","keywords":"","body":"1.介绍 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-26 02:37:02 "},"5-算法/5.5-链表/":{"url":"5-算法/5.5-链表/","title":"5.5-链表","keywords":"","body":"1.介绍 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-26 02:37:02 "},"5-算法/5.6-二分查找/":{"url":"5-算法/5.6-二分查找/","title":"5.6-二分查找","keywords":"","body":"1.介绍 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-26 02:37:02 "},"5-算法/5.7-树/":{"url":"5-算法/5.7-树/","title":"5.7-树","keywords":"","body":"1.介绍 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-26 02:37:02 "},"5-算法/5.8-二叉树/":{"url":"5-算法/5.8-二叉树/","title":"5.8-二叉树","keywords":"","body":"1.介绍 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-26 02:37:02 "},"5-算法/5.9-哈希表/":{"url":"5-算法/5.9-哈希表/","title":"5.9-哈希表","keywords":"","body":"1.介绍 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-26 02:37:02 "},"5-算法/解答模板.html":{"url":"5-算法/解答模板.html","title":"解答模板","keywords":"","body":"[TOC] 题目名 https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/ 输入 输出 示例 示例1 示例2 方法 方法1 思路 出口： 判断条件： 代码 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-03-02 17:17:42 "},"6-数据库/":{"url":"6-数据库/","title":"6-数据库","keywords":"","body":"Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 11:20:24 "},"7-数据结构/":{"url":"7-数据结构/","title":"7-数据结构","keywords":"","body":"Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 11:20:02 "},"7-数据结构/树/红黑树.html":{"url":"7-数据结构/树/红黑树.html","title":"红黑树","keywords":"","body":"Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 20:53:50 "},"8-操作系统/":{"url":"8-操作系统/","title":"8-操作系统","keywords":"","body":"操作系统 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-03-02 22:20:04 "},"9-计算机组成原理/":{"url":"9-计算机组成原理/","title":"9-计算机组成原理","keywords":"","body":"Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 11:20:18 "},"Linux/":{"url":"Linux/","title":"Linux","keywords":"","body":"Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-03-01 19:09:40 "},"Linux/常用命令.html":{"url":"Linux/常用命令.html","title":"常用命令","keywords":"","body":"基本操作 查看磁盘空间的命令 df 查看当前工作目录的命令 pwd 查看CPU当前的内存 top 查找文件 find [path] [options] [expression] Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-03-01 19:44:56 "},"建议/":{"url":"建议/","title":"建议","keywords":"","body":"Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 11:25:10 "},"建议/新到岗位的建议.html":{"url":"建议/新到岗位的建议.html","title":"新到岗位的建议","keywords":"","body":"新到岗位的建议 像刚实习，或者刚换工作的同学最好： 1.刚到新岗位，多沟通，不要闷声干。 2.尽快熟悉，对自己明确的工作安排。 3.积极主动，不懂就问，和同事保持良好关系。 4.多表现自己，但不要喧宾夺主，注意不要过度炫耀。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 12:58:58 "},"建议/程序员需要掌握的几种能力.html":{"url":"建议/程序员需要掌握的几种能力.html","title":"程序员需要掌握的几种能力","keywords":"","body":"程序员需要掌握的几种能力 1.解决问题能力 2.数学思维 3.专业能力 4.基本的编程逻辑思维 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 12:57:38 "},"逻辑思维/天平砝码分盐问题.html":{"url":"逻辑思维/天平砝码分盐问题.html","title":"天平砝码分盐问题","keywords":"","body":"天平发麻分盐问题 原文链接：https://blog.csdn.net/chk_plusplus/article/details/118099013 有两个砝码，一个7g，一个2g，还有一个天平。我们有140g的盐，要求称出固定的重量。 案例一：要求称出40g的盐 第一次用天平把140g盐平分，得到两堆70g的盐，仍然比40大很多，不到多退少补的时候。 第二次再用天平把70g盐平分，这堆70g的盐变成了两堆35g的盐 第三次，因为7g和2g放在天平两端就可以组合成5g的重量，因此我们给5g那段加盐到平衡，则那一端就得到了40g盐。 则一共需要三次即可 案例二：要求称出50g的盐 因为50*2 = 100，所以我们可以先把140g变成100g，然后天平平分即可，利用我们上面3次取40g的方法，只要多加一次平分，那么就得到了50g 但是如果要求称3次得出结果呢 第一次，用2g和7g砝码称出9g盐，现在有9g和131g 第二次：用7g和2g砝码可以把131g盐分成61g和70g（x + x - 9 = 131） 第三次：2g砝码和9g盐可以从61g盐中取出11g盐，即得50g盐 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-03-01 17:28:28 "},"逻辑思维/小明一家人过桥问题.html":{"url":"逻辑思维/小明一家人过桥问题.html","title":"小明一家人过桥问题","keywords":"","body":"小明一家人过桥问题 小明一家过一座桥，过桥时是黑夜，所以必须有灯。现在小明过桥要1秒，小明的弟弟要3秒，小明的爸爸要6秒，小明的妈妈要8秒，小明的爷爷要12秒。每次此桥最多可过两人，而过桥的速度依过桥最慢者而定，而且灯在点燃后30秒就会熄灭。问：小明一家如何过桥？ ​ 1、小明和小明弟弟过桥，需要花费3秒（小明弟弟慢，花3秒），计T1 = 3秒，总用时TC=3秒； ​ 2、小明回来，需要花费1秒，记T2=1秒，总用时TC=4秒； ​ 3、小明爷爷和小明妈妈一起过桥，需要花费12秒，记T3=12，总用时TC=16秒； ​ 4、小明弟弟回来，需要花费3秒，记T4=3秒，总用时TC=19秒； ​ 5、小明和小明爸爸一起过桥，需要花费6秒，记T5=6秒，总用时TC=25秒； ​ 6、小明回来，需要花费1秒，记T6=1秒，总用时TC=26秒； ​ 7、小明和小明弟弟一起过桥，需要花费3秒，记T7=3秒，总用时TC=29秒； Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-03-01 18:07:26 "}}