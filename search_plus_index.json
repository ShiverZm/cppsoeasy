{"./":{"url":"./","title":"Introduction","keywords":"","body":"cppsoeasy 知识库 主要记录： 面试cpp的知识点 刷题记录 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 13:30:26 "},"1-基础/":{"url":"1-基础/","title":"1-基础","keywords":"","body":"c和c++区别 C++是多范式编程（面向过程，面向对象，元编程，泛型编程）的语言，而C是面向过程的语言； C++引入new/delete运算符，取代了C中的malloc/free库函数； C++引入引用的概念，而C中没有； C++引入类的概念，而C中没有； C++引入函数重载的特性，而C中没有 元编程和泛型编程区别 元编程目的：代码生成代码 泛型编程目的：减小代码对特定数据类型的依赖 c++的模板元编程恰巧能同时做到。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 01:08:10 "},"1-基础/1.1-基础/":{"url":"1-基础/1.1-基础/","title":"1.1-基础","keywords":"","body":"Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 00:22:10 "},"1-基础/1.1-基础/1.1.1-c、c++区别.html":{"url":"1-基础/1.1-基础/1.1.1-c、c++区别.html","title":"1.1.1-c、c++区别","keywords":"","body":"c和c++区别 C++是面向对象的语言，而C是面向过程的语言； C++引入new/delete运算符，取代了C中的malloc/free库函数； C++引入引用的概念，而C中没有； C++引入类的概念，而C中没有； C++引入函数重载的特性，而C中没有 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 00:21:32 "},"1-基础/1.1-基础/1.1.10-内联函数.html":{"url":"1-基础/1.1-基础/1.1.10-内联函数.html","title":"1.1.10-内联函数","keywords":"","body":"内联函数 优点： 在内联函数被调用的地方进行代码展开，省去函数调用的时间，从而提高程序运行效率； 相比于宏函数，内联函数在代码展开时，编译器会进行语法安全检查或数据类型转换，使用更加安全； 缺点： 代码膨胀，产生更多的开销； 如果内联函数内代码块的执行时间比调用时间长得多，那么效率的提升并没有那么大； 如果修改内联函数，那么所有调用该函数的代码文件都需要重新编译； 内联声明只是建议，是否内联由编译器决定，所以实际并不可控。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 11:41:46 "},"1-基础/1.1-基础/1.1.2-a和&a区别.html":{"url":"1-基础/1.1-基础/1.1.2-a和&a区别.html","title":"1.1.2-a和&a区别","keywords":"","body":"Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 00:25:50 "},"1-基础/1.1-基础/1.1.3-static关键字作用.html":{"url":"1-基础/1.1-基础/1.1.3-static关键字作用.html","title":"1.1.3-static关键字作用","keywords":"","body":"static关键字作用 一般标识修饰的变量保存在静态存储区 c语言只能修饰局部静态变量和外部静态变量； C++，除了修饰局部静态变量和外部静态变量，还用来定义类的成员变量和函数。即静态成员和静态成员函数。 1.修改局部变量 该变量在 静态存储区 分配内存； 该变量只能在首次函数调用中进行首次初始化，之后的函数调用不再进行初始化； 该变量的生命周期与程序相同，但其作用域为局部作用域，并不能一直被访问； 2.修饰全局变量 修饰全局变量时，使得该变量在静态存储区 分配内存； 在声明该变量的整个文件中都是可见的，而在文件外是不可见的 3.修饰函数时 在声明该函数的整个文件中都是可见的，而在文件外是不可见的，从而可以在多人协作时避免同名的函数冲突； 4.修饰成员变量时 所有的对象都只维持一份拷贝，可以实现不同对象间的数据共享； 不需要实例化对象即可访问；不能在类内部初始化，一般在类外部初始化，并且初始化时不加static； 5. 修饰成员函数时 该函数不接受this指针，只能访问类的静态成员（函数和变量）； 不需要实例化对象即可访问。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 10:33:52 "},"1-基础/1.1-基础/1.1.4-变量的声明和定义.html":{"url":"1-基础/1.1-基础/1.1.4-变量的声明和定义.html","title":"1.1.4-变量的声明和定义","keywords":"","body":"变量的声明和定义 变量的定义为变量分配地址和存储空间， 变量的声明不分配地址。 (变量声明时会预定物理存储器，定义会分配物理存储器/使用物理存储器) 一个变量可以在多个地方声明， 但是只在一个地方定义。 加入extern 修饰的是变量的声明，说明此变量将在文件以外或在文件后面部分定义。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 00:53:00 "},"1-基础/1.1-基础/1.1.5-volatile作用以及注意点.html":{"url":"1-基础/1.1-基础/1.1.5-volatile作用以及注意点.html","title":"1.1.5-volatile作用以及注意点","keywords":"","body":"Volatile作用 修饰变量，标识编译器对访问该变量的代码就不再进行优化，常常用在多线程中，表示变量用完会写回内存中，而不是读取寄存器的备份。 注意点 指针也可以是volatile属性的，例如 volatile int * pInt; 一个参数可以既是const又是volatile 用const和volatile同时修饰变量，表示这个变量在程序内部是只读的，不能改变的，只在程序外部条件变化下改变，并且编译器不会优化这个变量。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 10:47:28 "},"1-基础/1.1-基础/1.1.6-全局变量和局部变量.html":{"url":"1-基础/1.1-基础/1.1.6-全局变量和局部变量.html","title":"1.1.6-全局变量和局部变量","keywords":"","body":"全局变量 存储位置：进程的全局数据段。 生命周期：程序运行到结束 特点：全局变量是整个程序都可访问的变量，谁都可以访问，生存期在整个程序从运行到结束（在程序结束时所占内存释放）； 局部变量 存储位置：进程的堆栈。 生命周期：作用域范围内。 特点：局部变量存在于模块（子程序，函数）中，只有所在模块可以访问，其他模块不可直接访问，模块结束（函数调用完毕），局部变量消失，所占据的内存释放。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 10:50:10 "},"1-基础/1.1-基础/1.1.7-memcpy、sprintf和strcpy.html":{"url":"1-基础/1.1-基础/1.1.7-memcpy、sprintf和strcpy.html","title":"1.1.7-memcpy、sprintf和strcpy","keywords":"","body":"memcpy、sprintf和strcpy 区别 memcpy sprintf strcpy 操作对象不同 memcpy 的两个对象就是两个任意可操作的内存地址，并不限于何种数据类型 sprintf 的操作源对象可以是多种数据类型， 目的操作对象是字符串 strcpy 的两个操作对象均为字符串 执行效率不同 memcpy 最高 sprintf 的效率最低 strcpy 次之 实现功能不同 memcpy 主要是内存块间的拷贝 sprintf 主要实现其他数据类型格式到字 符串的转化 strcpy 主要实现字符串变量间的拷贝 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 10:55:58 "},"1-基础/1.1-基础/1.1.8-memcpy、memmove和memccpy.html":{"url":"1-基础/1.1-基础/1.1.8-memcpy、memmove和memccpy.html","title":"1.1.8-memcpy、memmove和memccpy","keywords":"","body":"memcpy void *memcpy( void *dst, const void *src, size_t count ); 功能：拷贝src地址 count字节 到dst地址 返回值：该函数返回一个指向目标存储区 dst 的指针。 memmove void *memmove( void *dst, const void *src, size_t count ); 功能：memmove用于拷贝字节，如果目标区域和源区域有重叠的话，memmove能够保证源串在被覆盖之前将重叠区域的字节拷贝到目标区域中，但复制后源内容会被更改。但是当目标区域与源区域没有重叠则和memcpy函数功能相同 memccpy void *memccpy( void *dest, void *src, unsigned char c, unsigned int count ); 功能：由src所指内存区域复制不多于count个字节到dest所指内存区域，如果遇到字符c则停止复制。 返回值：如果c没有被复制，则返回NULL，否则，返回一个指向紧接着dest区域后的字符的指针。 区别与相同 相同：这三个函数的功能均是将某个内存块复制到另一个内存块， 区别：唯一的区别是，当内存发生局部重叠的时候，memmove保证拷贝的结果是正确的，memcpy不保证拷贝的结果的正确。 内存重叠问题 拷贝的目的地址在源地址的范围内，有重叠。 例如： char s[32] = \"abcdefg\"; char* p = s; p++: strcpy(p, s); Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 10:59:44 "},"1-基础/1.1-基础/1.1.9-共用体.html":{"url":"1-基础/1.1-基础/1.1.9-共用体.html","title":"1.1.9-共用体","keywords":"","body":"共用体 常见问题 字节对齐 当说明一个共用体变量时，系统分配给它的内存的大小是： 当最大的变量的大小 ```cpp union TestUnion { int a;// 4 byte float b;//4 byte char c;//1 byte }; 输出结果是:4 2. 当最大的变量的大小 >= 最大类型的大小，是最大类型的整数倍。（要考虑内存对齐） ```cpp union TestUnion { int a;// 4 byte float b;//4 byte char c[12];//12 byte double d;//8 byte }; 输出结果是:16 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 11:11:36 "},"1-基础/1.2-数组/":{"url":"1-基础/1.2-数组/","title":"1.2-数组","keywords":"","body":"1.2 数组 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-27 22:20:10 "},"1-基础/1.2-数组/1.2.1-数组越界.html":{"url":"1-基础/1.2-数组/1.2.1-数组越界.html","title":"1.2.1-数组越界","keywords":"","body":"数组越界不报错 以下运行结果 int main2() { int i; int a[5] = {0}; for (i = 0; i 这段代码结果就是：无限循环输出。 原因： 数组越界不报错 只会警告：C6201:索引\"30\"超出了“O\"至\"4\"的有效范围(对于可能在堆栈中分配的缓冲区\"a\")。 越界访问会访问了修改了i值 a内存空间 从0x00CFF7E0到 0x00CFF7F2 20个字节 5个Int长度 i为0x00CFF7FC即位置 越界访问会访问到i值，同时a[i] = 0;会把i置空为0，导致i=0;所以会一直循环。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 11:09:16 "},"1-基础/1.3-字符串/":{"url":"1-基础/1.3-字符串/","title":"1.3-字符串","keywords":"","body":"Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 10:33:02 "},"1-基础/1.3-字符串/1.3.1-sizeof和strlen.html":{"url":"1-基础/1.3-字符串/1.3.1-sizeof和strlen.html","title":"1.3.1-sizeof和strlen","keywords":"","body":"sizeof 和strlen 的区别 类型 sizeof：是一个操作符； strlen：是库函数，string.h头文件里的； 形数类型 sizeof：sizeof的参数可以是数据的类型，也可以是变量； strlen：只能以结尾为‘\\0’的字符串作参数。 运行时期和作用 sizeof：编译器在编译时就计算出了sizeof的结果， strlen：strlen函数必须在运行时才能计算出来。 并且sizeof计算的是数据类型占内存的大小，而strlen计算的是字符串实际的长度。 数组做sizeof的参数不退化，传递给strlen就退化为指针了 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 10:37:40 "},"1-基础/1.4-指针与引用/":{"url":"1-基础/1.4-指针与引用/","title":"1.4-指针与引用","keywords":"","body":"指针 定义：指针是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。 形式： - 声明：type *var-name; 例如：int i = 10; int *pNum = &i; - 取值：*var-name; 例如: *pNum; 大小：4字节（32位程序），8字节（64位程序） 引用 一般指左值引用。 定义：引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。 形式： 声明：type &var-name = var; 例如：int &refNum = i; 大小：原类型大小，sizeof(type); 右值引用 c++11的特性 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 10:30:46 "},"1-基础/1.4-指针与引用/1.4.1-指针和引用的区别.html":{"url":"1-基础/1.4-指针与引用/1.4.1-指针和引用的区别.html","title":"1.4.1-指针和引用的区别","keywords":"","body":"指针和引用的区别 参考知乎：C++中指针与引用的区别 1. 两者的定义和性质不同 指针是一个变量，存储的是一个地址，指向内存的一个存储单元； 引用是原变量的一个别名，跟原来的变量实质上是同一个东西，跟原来的变量用的同一块内存。 2.指针可以有多级，引用只能是一级 int **p; // 合法 int &&a; // 不合法 3.指针可以在定义的时候不初始化，引用必须在定义的时候初始化 int *p; // 合法 int &r; // 不合法 int a = 996; int &r = a; // 合法 4.指针可以指向NULL，引用不可以为NULL int *p = NULL; // 合法 int &r = NULL; // 不合法 5.指针初始化之后可以再改变，引用不可以 int a = 996; int *p = &a; // 初始化, p 是 a 的地址 int &r = a; // 初始化, r 是 a 的引用 int b = 885; p = &b; // 合法, p 更改为 b 的地址 r = b; // 不合法, r 不可以再变 6.sizeof 的运算结果不同 指针大小：4字节或8字节，根据程序位数有关； 引用大小：是原对象的大小； int a = 996; int *p = &a; int &r = a; cout 7、自增运算意义不同 指针自增：指针地址偏移一个type单位； 引用自增：原对象的值自增； int a = 996; int *p = &a; int &r = a; p++;//p++之后指向a后面的内存 r++;//r++相当于a++。 8.指针和引用作为函数参数时，指针需要检查是否为空，引用不需要 void fun_p(int *p) { // 需要检查P是否为空 if (p == NULL) { // do something } } void fun_r(int &r) { // 不需要检查r // do something } Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-27 19:34:44 "},"1-基础/1.4-指针与引用/1.4.2-指针和引用使用的场景.html":{"url":"1-基础/1.4-指针与引用/1.4.2-指针和引用使用的场景.html","title":"1.4.2-指针和引用使用的场景","keywords":"","body":"指针和引用使用的场景 参考知乎：设计C++函数传参时如何决定使用指针还是引用？ 1. 函数不是构造函数，且参数是只读：用const引用。 如果函数参数是只读的，且不是构造函数，const引用最好。 原因： 如果用指针，用户使用时可能会传nullptr作为参数。 用引用的话，用户基本不可能犯这种错误。 const reference 可以接受匿名变量作为参数。 比如， 2.函数不是构造函数，且参数是作为输出(out)参数：用指针。 这种情况用指针最好。因为用户在传指针的时候需要用到取地址操作符(&)，这样代码看起来更易懂。 比如： void copy1(const std::string &a, std::string *b); void copy2(const std::string &a, std::string &b); copy1(foo, &bar);//指针输出 copy2(foo, bar);//引用作输出 3.函数不是构造函数，且不是只读，但也不是输出参数：用引用。 原因： 这种情况用引用比用指针好是引用可以防止不小心传nullptr这种情况。 4.函数是构造器，但参数并不参与组成构造类的一部分，那就参考以上几点。 5.函数是构造器，且参数参与构造，且参数是可移动的类型：传值。 这种情况直接传值是最好的。比如： class person { public: person(std::string name) : name_{std::move(name)} {} private: std::string name_; }; 传值比传const引用好处在于，取决于用户是否需要保留原参，可以省略复制。比如， Person p{\"Jack\"}; // 创建一个临时变量，如果一个move；多半情况下编译器会直接创建在Person里 std::string name{\"John\"}; Person p1{name}; // 这种情况跟用const引用一样，都是一次copy Person p2{std::move(name)}; // 因为被转化成了右值，name会被直接移动到p2里，省掉一次copy 当然，如果string是像这个例子中这么小的话，move和copy开销是一样的，因为small string optimization。 但如果参数是长的string，或者类似于vector或者map这种heap allocated变量的话，move就比copy开销小非常多。 6. 函数是构造器，且参数参与构造，但构造的类只保留参数的引用：传shared_ptr或者自定义指针（不推荐） 首先我非常不提倡这种类型，因为如果这样定义，用户就必须保证name的生命周期比person长。但只看构造器的签名的话又没办法看出来这点。用起来非常麻烦，每次都需要查文档或者读代码才能知道用name构建了person之后能不能销毁name。比如如果你这样定义这个类： class person { public: person(const family_tree &family) : family_{&name} { family_->add(this); } private: const family_tree *family_; }; family_tree family{...}; person p{family}; //只看这两行代码你能知道可不可以return p吗？ 我一般只有当类是作为函数类型用的时候才会定义这种类型。其他情况，我一般会用shared_ptr作为参数，然后类里也保存shared_ptr作为成员。比如像这样， class person { public: person(std::shared_ptr family) : family_{std::move(family)} {} private: std::shared_ptr family_; }; 但这样如果family是stack上的变量且我可以保证family的生命周期比person长怎么办？其实很容易，这样就行了： int main() { family_tree family{...}; person p{shared_ptr(&family, [](family_tree *) {})}; ... } Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-27 22:18:50 "},"1-基础/1.4-指针与引用/1.4.3-delete、free和new、malloc的异同.html":{"url":"1-基础/1.4-指针与引用/1.4.3-delete、free和new、malloc的异同.html","title":"1.4.3-delete、free和new、malloc的异同","keywords":"","body":"delete、free和new、malloc的异同 new、malloc区别 区别点 new malloc 1.申请的内存所在位置 自由存储区（free store）上为对象动态分配内存空间 从堆上动态分配内存。 2.返回类型安全性 返回标准类型指针。 返回void* 3.内存分配失败时的返回值 内存分配失败时，会抛出bac_alloc异常，它不会返回NULL； 分配内存失败时返回NULL。 4.是否需要指定内存大小 申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算， 需要显式地指出所需内存的尺寸。 5.是否调用构造函数/析构函数 调用构造 不调用 6.对数组的处理，C++提供了new[]与delete[]来专门处理数组类型 7.new与malloc是否可以相互调用 8.是否可以被重载 new/delete可以重载 free/malloc是函数，可以写同名函数，重载函数。 9.能够直观地重新分配内存 10.客户处理内存分配不足 自由存储区：C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。 堆：操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。 注意： 自由存储区是否是堆：需要看new的实现，自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。 注意： delete一般是不可以释放malloc的资源，free和new一样。但对于简单类型单单释放是不会报错的，对于对象类型的话，可能会存在问题。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-27 22:59:28 "},"1-基础/1.4-指针与引用/1.4.4-野指针.html":{"url":"1-基础/1.4-指针与引用/1.4.4-野指针.html","title":"1.4.4-野指针","keywords":"","body":"野指针 定义：指针指向未知内存，导致访问越界/非法访问等问题。 几种情况： 指针没初始化 指针指向的内存释放后，指针没置空 指针操作超越了变量的作用范围 如何避免野指针 指针变量声明时没有被初始化。 解决办法：指针声明时初始化，可以是具体的地址值，也可让它指向NULL。 指针p被free或者delete之后，没有置为NULL。 解决办法：指针指向的内存空间被释放后指针应该指向NULL。 指针操作超越了变量的作用范围。 解决办法：在变量的作用域结束前释放掉变量的地址空间并且让指针指向NULL。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 12:46:30 "},"1-基础/1.4-指针与引用/1.4.5-内存泄漏.html":{"url":"1-基础/1.4-指针与引用/1.4.5-内存泄漏.html","title":"1.4.5-内存泄漏","keywords":"","body":"内存泄漏 定义：堆区内存（new/malloc）没有释放，导致运行时内存增加，直到一定程度导致程序崩溃。 内存泄漏场景 malloc和free未成对出现；new/new []和delete/delete []未成对出现； 1>在堆中创建对象分配内存，但未显式释放内存；比如，通过局部分配的内存，未在调用者函数体内释放： 2>在构造函数中动态分配内存，但未在析构函数中正确释放内存； 未定义拷贝构造函数或未重载赋值运算符，从而造成两次释放相同内存的做法；比如，类中包含指针成员变量，在未定义拷贝构造函数或未重载赋值运算符的情况下，编译器会调用默认的拷贝构造函数或赋值运算符，以逐个成员拷贝的方式来复制指针成员变量，使得两个对象包含指向同一内存空间的指针，那么在释放第一个对象时，析构函数释放该指针指向的内存空间，在释放第二个对象时，析构函数就会释放同一内存空间，这样的行为是错误的； 没有将基类的析构函数定义为虚函数。 内存泄漏常见解决方案 MFC DEBUG_NEW 重载new/delete Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 00:55:22 "},"1-基础/1.4-指针与引用/1.4.6-悬挂指针.html":{"url":"1-基础/1.4-指针与引用/1.4.6-悬挂指针.html","title":"1.4.6-悬挂指针","keywords":"","body":"悬挂指针 悬挂指针：当指针所指向的对象被释放，但是该指针没有任何改变，以至于其仍然指向已经被回收的内存地址，这种情况下该指针被称为悬挂指针； 野指针 野指针：未初始化的指针被称为野指针。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 11:21:26 "},"1-基础/1.4-指针与引用/1.4.7-指针常量与常量指针区别.html":{"url":"1-基础/1.4-指针与引用/1.4.7-指针常量与常量指针区别.html","title":"1.4.7-指针常量与常量指针区别","keywords":"","body":"指针常量 本质是一个常量，而用指针修饰它。指针常量的值是指针，这个值因为是常量，所以不能被赋值。 形式： int* const p; 注意： 它是个常量！ 指针所保存的地址可以改变，然而指针所指向的值却不可以改变； 指针本身是常量，指向的地址不可以变化,但是指向的地址所对应的内容可以变化； 常量指针 常指针，指向一个常量的指针。 形式： int const* p; const int* p; 例如： const int i =123;//常量 int const* p = i; //指向常量的指针 注意： 常指针不能通过指针修改值的内容。（常量不可修改） 指针还可以指向别处，因为指针本身只是个变量，可以指向任意地址。 指向常量的常指针 指向常量的指针常量就是一个常量，且它指向的对象也是一个常量。 形式： const int* const p; 注意： 一个指针常量，指向的是一个指针对象； 它指向的指针对象且是一个常量，即它指向的对象不能变化； 区别 是否是常量 指针指向的内容是否可以修改 是否可以通过指针修改指向的内容 指针常量 是 是 否 常量指针 否 是 否 指向常量的常（量）指针 是 否 否 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 12:44:56 "},"1-基础/1.4-指针与引用/1.4.8-句柄和指针.html":{"url":"1-基础/1.4-指针与引用/1.4.8-句柄和指针.html","title":"1.4.8-句柄和指针","keywords":"","body":"句柄 句柄：暴露部分数据结构和结构，隐藏不想暴露的部分。 Windows系统用句柄标记系统资源，隐藏系统的信息。你只要知道有这个东西，然后去调用就行了，它是个32it的uint。 例如： Windows 窗口句柄 HWND hWnd; 句柄和指针区别 Windows系统用句柄标记系统资源，隐藏系统的信息。你只要知道有这个东西，然后去调用就行了，它是个32it的uint。 指针则标记某个物理内存地址，两者是不同的概念。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 12:49:18 "},"1-基础/1.5-面向对象/":{"url":"1-基础/1.5-面向对象/","title":"1.5-面向对象","keywords":"","body":"c和c++区别 C++是面向对象的语言，而C是面向过程的语言； C++引入new/delete运算符，取代了C中的malloc/free库函数； C++引入引用的概念，而C中没有； C++引入类的概念，而C中没有； C++引入函数重载的特性，而C中没有 面向对象基本特征 封装，继承，多态。 封装 定义：就是隐藏对象的属性和实现细节，仅对外公开接口（method），控制在程序中属性的读和修改的访问级别（public/protected/private）。 目的：封装的目的是增强安全性和简化编程，使用者不必了解具体的实现细节，而只是要通过外部接口，以特定的访问权限来使用类的成员。 继承 是面向对象的基本特征之一，继承机制允许创建分等级层次的类。 定义：继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。 注意：C++支持多重继承（java只支持 单继承），可能会导致菱形继承。 多态 定义：多态同一个行为具有多个不同表现形式或形态的能力。是指一个类实例（对象）的相同方法在不同情形有不同表现形式。（主要体现在重写和重载，上转型） Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 00:21:56 "},"1-基础/1.5-面向对象/1.5.1-重写和覆盖的区别.html":{"url":"1-基础/1.5-面向对象/1.5.1-重写和覆盖的区别.html","title":"1.5.1-重写和覆盖的区别","keywords":"","body":"重写和覆盖的区别 重写：基类有virtual， 派生类继承过来，重新实现函数。如果上转，则调用子类的。 覆盖：基类没有virtual，派生类有基类同名且同参数返回值的函数，基类和派生类都有这个函数，互不干扰。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-27 23:04:38 "},"1-基础/1.5-面向对象/1.5.10-虚继承.html":{"url":"1-基础/1.5-面向对象/1.5.10-虚继承.html","title":"1.5.10-虚继承","keywords":"","body":"虚继承 为了解决多继承时的命名冲突和冗余数据问题，C++提出了虚继承，使得在派生类中只保留一份间接基类的成员。 在继承方式前面加上 virtual 关键字就是虚继承，请看下面的例子： //间接基类A class A{ protected: int m_a; }; //直接基类B class B: virtual public A{ //虚继承 protected: int m_b; }; //直接基类C class C: virtual public A{ //虚继承 protected: int m_c; }; //派生类D class D: public B, public C{ public: void seta(int a){ m_a = a; } //正确 void setb(int b){ m_b = b; } //正确 void setc(int c){ m_c = c; } //正确 void setd(int d){ m_d = d; } //正确 private: int m_d; }; int main(){ D d; return 0; } Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 16:01:06 "},"1-基础/1.5-面向对象/1.5.11-空类的大小和成员函数.html":{"url":"1-基础/1.5-面向对象/1.5.11-空类的大小和成员函数.html","title":"1.5.11-空类的大小和成员函数","keywords":"","body":"空类的大小 sizeof(A)的值为1，因为编译器需要区分这个空类的不同实例，分配一个字节，可以使这个空类的不同实例拥有独一无二的地址。 空类的成员函数 缺省构造函数()。 缺省拷贝构造函数copy()。 省析构函数~()。 赋值运算符opreate=。 取址运算符operator&。 取址运算符 operator& const 。 注意： 有些书上只是简单的介绍了前四个函数。没有提及后面这两个函数。但后面这两个函数也是 空类的默认函数。另外需要注意的是，只有当实际使用这些函数的时候，编译器才会去定义它们。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 16:39:14 "},"1-基础/1.5-面向对象/1.5.12-类和结构体的区别.html":{"url":"1-基础/1.5-面向对象/1.5.12-类和结构体的区别.html","title":"1.5.12-类和结构体的区别","keywords":"","body":"struct和class 默认继承权限不同，class继承默认是private继承，而struct默认是public继承 模板参数， class还可用于定义模板参数，像typename，但是关键字struct不能用于定义模板参数 C++保留struct关键字，主要有如下原因 兼容C语言：保证与C语言的向下兼容性，C++必须提供一个struct C++中的struct定义必须百分百地保证与C语言中的struct的向下兼容性，把C++中的最基本的对象单元规定为class而不是struct，就是为了避免各种兼容性要求的限制 便于移植C语言，对struct定义的扩展使C语言的代码能够更容易的被移植到C++中 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 16:16:28 "},"1-基础/1.5-面向对象/1.5.2-多态的具体表现.html":{"url":"1-基础/1.5-面向对象/1.5.2-多态的具体表现.html","title":"1.5.2-多态的具体表现","keywords":"","body":"几种具体的表现 重写 子类继承父类后对父类方法进行重新定义。 重载 对已有方法的参数类型和数量的改变。 覆盖 基类没有virtual，派生类有基类同名且同参数返回值的函数 上转型（子类转父类） 父类引用指向子类对象。 Parent* pParent = new Child; Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-27 23:06:24 "},"1-基础/1.5-面向对象/1.5.3-多态的实现.html":{"url":"1-基础/1.5-面向对象/1.5.3-多态的实现.html","title":"1.5.3-多态的实现","keywords":"","body":"多态的实现 多态分为静态多态和动态多态。 静态多态、 其中，静态多态是通过重载和模板技术实现的，在编译期间确定； 动态多态 动态多态是通过虚函数和继承关系实现的，执行动态绑定，在运行期间确定。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-27 23:23:48 "},"1-基础/1.5-面向对象/1.5.4-构造和析构函数.html":{"url":"1-基础/1.5-面向对象/1.5.4-构造和析构函数.html","title":"1.5.4-构造和析构函数","keywords":"","body":"构造函数 析构函数 对象创建到销毁构造析构调用顺序 A：基类； B：派生类； 从创建到销毁构造析构调用顺序。 graph TB A(A构造)-->B(B构造); B-->C(B析构); C-->D(A析构); 常见问题 1.构造函数不可以是虚函数 虚函数的调用依赖于虚函数表，而指向虚函数表的指针vptr需要在构造函数中进行初始化，所以无法调用定义为虚函数的构造函数。 2.构造/析构函数不占据内存空间 对象的大小是指在类实例化出的对象当中，他的数据成员所占据的内存大小，而不包括成员函数，所以不占用。 3.基类的析构函数需要定义为虚函数 为了实现动态绑定，基类指针指向派生类对象，如果析构函数不是虚函数，那么在对象销毁时，就会调用基类的析构函数，只能销毁派生类对象中的部分数据，所以必须将析构函数定义为虚函数，从而在对象销毁时，调用派生类的析构函数，从而销毁派生类对象中的所有数据。 主要是： 多态上转型接收时 如果不是虚析构，对象销毁时会调用基类的析构函数。 同时，虚析构时，才会调用到派生类的析构。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 15:45:58 "},"1-基础/1.5-面向对象/1.5.5-构造初始化.html":{"url":"1-基础/1.5-面向对象/1.5.5-构造初始化.html","title":"1.5.5-构造初始化","keywords":"","body":"拷贝初始化和直接初始化区别 类型 形式 说明 直接初始化 ClassTest ct1(“ab”) 它不需要调用复制构造函数，直接调用构造函数ClassTest(constchar *pc)，所以当复制构造函数变为私有时，它还是能直接执行的。 ClassTest ct4（ct1） 因为 ct1 本来已经存在，直接调用复制构造函数，生成对象 ct3 的副本对象 ct4。所以当复制构造函数变为私有时，该语句不能编译通过。 复制初始化 ClassTest ct2 = “ab” 它首先调用构造函数 ClassTest(const char* pc) 函数创建一个临时对象， 然后调用复制构造函数，把这个临时对象作为参数，构造对象ct2；所以当复制构造函数变为私有时，该语句不能编译通过。 ClassTest ct3 = ct1; 因为 ct1 本来已经存在，所以不需要调用相关的构造函数，而直接调用复制构造函数把它值复制给对象 ct3；所以当复制构造函数变为私有时，该语句不能编译通过。 初始化和赋值的区别 调用的函数不同 初始化：调用构造函数。 赋值：调用复制构造函数。 是否创建临时对象 初始化：不创建。 赋值：传入形参时，创建。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 13:28:54 "},"1-基础/1.5-面向对象/1.5.6-纯虚函数作用.html":{"url":"1-基础/1.5-面向对象/1.5.6-纯虚函数作用.html","title":"1.5.6-纯虚函数作用","keywords":"","body":"纯虚函数 定义纯虚函数是为了实现一个接口，起到规范的作用，想要继承这个类就必须覆盖该函数。 形式 实现方式是在虚函数声明的结尾加上= 0即可。 class AbstractClasss{ publi: virtual void Export() = 0; } 作用 定义纯虚函数是为了实现一个接口，起到规范的作用，对外表示接口。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 15:29:02 "},"1-基础/1.5-面向对象/1.5.7-虚函数表.html":{"url":"1-基础/1.5-面向对象/1.5.7-虚函数表.html","title":"1.5.7-虚函数表","keywords":"","body":"虚函数表 虚函数表是针对类的，类的所有对象共享这个类的虚函数表。 因为每个对象内部都保存一个指向该类虚函数表的指针vptr，每个对象的vptr的存放地址都不同，但都指向同一虚函数表。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 15:32:10 "},"1-基础/1.5-面向对象/1.5.8-禁止类的实例化.html":{"url":"1-基础/1.5-面向对象/1.5.8-禁止类的实例化.html","title":"1.5.8-禁止类的实例化","keywords":"","body":"禁止类的实例化 方法 声明为private 将类定义为抽象类（也就是存在纯虚函数）或者将构造函数声明为private。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 15:49:16 "},"1-基础/1.5-面向对象/1.5.9-多继承相关.html":{"url":"1-基础/1.5-面向对象/1.5.9-多继承相关.html","title":"1.5.9-多继承相关","keywords":"","body":"多继承可能存在的问题 增加程序的复杂度， 使得程序的编写和维护比较困难，容易出错； 成员变量的同名二义性：在继承时，基类之间或基类与派生类之间发生成员同名时，将出现对成员访问的不确定性，即同名二义性； 消除多继承中的二义性： 利用作用域运算符::，用于限定派生类使用的是哪个基类的成员； 在派生类中定义同名成员，覆盖基类中的相关成员； 成员变量的路径二义性 当派生类从多个基类派生，而这些基类又从同一个基类派生，则在访问此共同基类的成员时，将产生另一种不确定性，即路径二义性；（菱形继承） 消除路径二义性的方法： 消除同名二义性的两种方法都可以； 使用虚继承，使得不同路径继承来的同名成员在内存中只有一份拷贝。 （class A：virtual public Base） Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 16:00:30 "},"1-基础/1.7-宏定义/1.7.2-typedef和define.html":{"url":"1-基础/1.7-宏定义/1.7.2-typedef和define.html","title":"1.7.2-typedef和define","keywords":"","body":"typedef typedef 和define区别 用法不同：typedef 用来定义一种数据类型的别名，增强程序的可读性。define 主要用来定义 常量，以及书写复杂使用频繁的宏。 执行时间不同：typedef 是编译过程的一部分，有类型检查的功能。define 是宏定义，是预编译的部分，其发生在编译之前，只是简单的进行字符串的替换，不进行类型的检查。 作用域不同：typedef 有作用域限定。define 不受作用域约束，只要是在define 声明后的引用 都是正确的。 对指针的操作不同：typedef 和define 定义的指针时有很大的区别。 注意： typedef 定义是语句，因为句尾要加上分号。而define 不是语句，千万不能在句尾加分号。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 12:02:44 "},"2-高级/":{"url":"2-高级/","title":"2-高级","keywords":"","body":"2.高级篇 主要： 标准库 STL string 容器（数据的存放形式，包括序列式容器和关联式容器） 算法库（排序，复制等常用算法，以及不同容器特定的算法） 迭代器（就是在不暴露容器内部结构的情况下对容器的遍历） 时间库（时间、日期、本地化库） 线程库 文件操作 面向对象 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 16:58:18 "},"2-高级/2.1-string/":{"url":"2-高级/2.1-string/","title":"2.1-string","keywords":"","body":"std::string C++ 98的特性 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 01:03:26 "},"2-高级/2.1-string/2.1.1-string的sizeof.html":{"url":"2-高级/2.1-string/2.1.1-string的sizeof.html","title":"2.1.1-string的sizeof","keywords":"","body":"sizeof std::string sizeof(std::string)的结果 可能是 4、12，32\\28。 string的实现在各库中可能有所不同，但是在同一库中相同一点是，无论你的string里放多长的字符串，它的sizeof()都是固定的，字符串所占的空间是从堆中动态分配的，与sizeof()无关。 sizeof(string) == 4 可能是最为典型的实现之一， 不过也有sizeof()为 12，32 字节的库， 同时也与编译器有关，在windows 32位操作系统下， 使用vs2013/vs2015编译器测试，sizeof(string) == 28。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 01:00:36 "},"2-高级/2.2-容器/":{"url":"2-高级/2.2-容器/","title":"2.2-容器","keywords":"","body":"Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-26 02:37:02 "},"2-高级/2.2-容器/2.2.1-vector.html":{"url":"2-高级/2.2-容器/2.2.1-vector.html","title":"2.2.1-vector","keywords":"","body":"Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-26 02:37:02 "},"2-高级/2.2-容器/2.2.2-list.html":{"url":"2-高级/2.2-容器/2.2.2-list.html","title":"2.2.2-list","keywords":"","body":"Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-26 02:37:02 "},"2-高级/2.2-容器/2.2.3-map.html":{"url":"2-高级/2.2-容器/2.2.3-map.html","title":"2.2.3-map","keywords":"","body":"Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-26 02:37:02 "},"2-高级/2.2-容器/2.2.4-set.html":{"url":"2-高级/2.2-容器/2.2.4-set.html","title":"2.2.4-set","keywords":"","body":"Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-26 02:37:02 "},"2-高级/2.3-时间日期本地化库/":{"url":"2-高级/2.3-时间日期本地化库/","title":"2.3-时间日期本地化库","keywords":"","body":"2.2 其他一般属性 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-26 02:37:02 "},"2-高级/2.4-算法库/":{"url":"2-高级/2.4-算法库/","title":"2.4-算法库","keywords":"","body":"Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-26 02:37:02 "},"2-高级/2.5-内存管理/2.5.1-深拷贝和浅拷贝.html":{"url":"2-高级/2.5-内存管理/2.5.1-深拷贝和浅拷贝.html","title":"2.5.1-深拷贝和浅拷贝","keywords":"","body":"深拷贝和浅拷贝 浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享一块内存； 深拷贝会创造一个相同的对象，新对象与原对象不共享内存，修改新对象不会影响原对象。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 00:58:20 "},"2-高级/2.5-内存管理/2.5.2-左值引用和右值引用.html":{"url":"2-高级/2.5-内存管理/2.5.2-左值引用和右值引用.html","title":"2.5.2-左值引用和右值引用","keywords":"","body":"引用和右值引用 C++对于左值和右值没有标准定义，但是有一个被广泛认同的说法： 可以取地址的，有名字的，非临时的就是左值； 不能取地址的，没有名字的，临时的就是右值； 右值引用 c++ 11 特性 类型 && 引用名 = 右值表达式; int &&var = 10; 右值引用的存在并不是为了取代左值引用，而是充分利用右值(特别是临时对象)的构造来减少对象构造和析构操作以达到提高效率的目的。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 11:36:04 "},"2-高级/2.5-内存管理/2.5.3-拷贝构造和赋值操作符重载.html":{"url":"2-高级/2.5-内存管理/2.5.3-拷贝构造和赋值操作符重载.html","title":"2.5.3-拷贝构造和赋值操作符重载","keywords":"","body":"拷贝构造函数和赋值运算符重载区别 拷贝构造函数用于构造新的对象 Student s; Student s1 = s; // 隐式调用拷贝构造函数 Student s2(s); // 显式调用拷贝构造函数 赋值运算符重载用于将源对象的内容拷贝到目标对象中，而且若源对象中包含未释放的内存需要先将其释放 Student s; Student s1; s1 = s; // 使用赋值运算符 一般情况下，类中包含指针变量时需要重载拷贝构造函数、赋值运算符和析构函数。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 16:12:18 "},"2-高级/2.5-内存管理/2.5.4-字节对齐.html":{"url":"2-高级/2.5-内存管理/2.5.4-字节对齐.html","title":"2.5.4-字节对齐","keywords":"","body":"字节对齐基本原则 结构体内最大长度的变量为一次访问长度 结构体对齐 关键字#programma Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 16:13:00 "},"2-高级/2.5-内存管理/2.5.5-内存分配的几种方式.html":{"url":"2-高级/2.5-内存管理/2.5.5-内存分配的几种方式.html","title":"2.5.5-内存分配的几种方式","keywords":"","body":"内存分配的几种方式 1.栈上分配 在执行函数时，局部变量的内存都可以在栈上分配，函数结束时会自动释放；栈内存的分配运算内置于处理器的指令集中，效率很高，但分配的内存容量有限 2.堆上分配 就是那些由malloc分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般malloc就要对应一个 free。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收 3.自由存储区 从自由存储区分配：如果说堆是操作系统维护的一块内存，那么自由存储区就是C++中通过new和delete动态分配和释放对象的抽象概念。需要注意的是，自由存储区和堆比较像，但不等价。 c++的new 一般在自由存储区，自由存储区是抽象层，看平台的实现，有的平台是用堆实现，有的不是。 4.常量存储区 从常量存储区分配：特殊的存储区，存放的是常量，不可修改； 5.全局/静态存储区 从全局/静态存储区分配：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量和静态变量又分为初始化的和未初始化的，在C++里面没有这个区分了，它们共同占用同一块内存区，在该区定义的变量若没有初始化，则会被自动初始化，例如int型变量自动初始为0 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 16:10:40 "},"2-高级/2.6-智能指针/":{"url":"2-高级/2.6-智能指针/","title":"2.6-智能指针","keywords":"","body":"智能指针 为了更加容易（更加安全）的使用动态内存，引入了智能指针的概念。智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。 智能指针是一个RAII类模型，用于动态分配内存，其设计思想是将基本类型指针封装为（模板）类对象指针，并在离开作用域时调用析构函数，使用delete删除指针所指向的内存空间。 分为以下几种： auto_ptr、unique_ptr、shared_ptr和weak_ptr auto_ptr 实现独占式拥有的概念，同一时间只能有一个智能指针可以指向该对象。 但auto_ptr在C++11中被摒弃，其主要问题在于： 对象所有权的转移，比如在函数传参过程中，对象所有权不会返还，从而存在潜在的内存崩溃问题； 不能指向数组，也不能作为STL容器的成员。 unique_ptr 实现独占式拥有的概念，同一时间只能有一个智能指针可以指向该对象。 因为无法进行拷贝构造和拷贝赋值，但是可以进行移动构造和移动赋值； shared_ptr 实现共享式拥有的概念，即多个智能指针可以指向相同的对象，该对象及相关资源会在其所指对象不再使用之后，自动释放与对象相关的资源； weak_ptr 解决shared_ptr相互引用时，两个指针的引用计数永远不会下降为0，从而导致死锁问题。而weak_ptr是对对象的一种弱引用，可以绑定到shared_ptr，但不会增加对象的引用计数。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 11:59:10 "},"2-高级/2.7-常用知识/2.7.1-类型转换.html":{"url":"2-高级/2.7-常用知识/2.7.1-类型转换.html","title":"2.7.1-类型转换","keywords":"","body":"类型转换 为什么不使用C的强制转换？ C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。 类型 参数对象类型 特点 static_cast 基本数据类型、子类向父类的安全转换、void*和其他类型指针。 向下转化不安全。 const_cast 使用const或volatile修饰符的变量。 去掉const属性 dynamic_cast 对象的类层次间的向上和向下转化 向下转化安全，有类型检查 reinterpret_cast 不同类型指针之间、不同类型引用之间、指针和能容纳指针的整数类型 什么都能转，但少用。 static_cast 用于基本数据类型之间的转换、子类向父类的安全转换、void*和其他类型指针之间的转换。 比如非const转const，void*转指针等, static_cast能用于多态向上转化，如果向下转能成功但是不安全，结果未知； const_cast 用于去除const或volatile属性； dynamic_cast 用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。 因为编译器默认向上转换总是安全的，而向下转换时，dynamic_cast具有类型检查的功能； dynamic_cast转换失败时，对于指针会返回目标类型的nullptr，对于引用会返回bad_cast异常； 向上转换：指的是子类向基类的转换 向下转换：指的是基类向子类的转换 reinterpret_cast 用于不同类型指针之间、不同类型引用之间、指针和能容纳指针的整数类型之间的转换。 几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用； Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 16:21:04 "},"2-高级/2.7-常用知识/2.7.2-动态链接和静态链接.html":{"url":"2-高级/2.7-常用知识/2.7.2-动态链接和静态链接.html","title":"2.7.2-动态链接和静态链接","keywords":"","body":"静态链接 静态链接：是在编译链接时直接将需要的执行代码拷贝到调用处； 优点：在于程序在发布时不需要依赖库，可以独立执行，、 缺点：在于程序的 体积会相对较大，而且如果静态库更新之后，所有可执行文件需要重新链接； 动态链接 动态链接：是在编译时不直接拷贝执行代码，而是通过记录一系列符号和参数，在程序运行或加载时将这些信息传递给操作系统，操作系统负责将需要的动态库加载到内存中，然后程序在运行到指定代码时，在共享执行内存中寻找已经加载的动态库可执行代码，实现运行时链接； 优点：在于多个程序可以共享同一个动态库，节省资源； 缺点：在于由于运行时加载，可能影响程序的前期执行性能。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 11:17:06 "},"2-高级/2.7-常用知识/2.7.3-main函数.html":{"url":"2-高级/2.7-常用知识/2.7.3-main函数.html","title":"2.7.3-main函数","keywords":"","body":"main函数 main函数执行之前进行的操作 设置栈指针； 初始化static静态和global全局变量，即data段的内容； 将未初始化部分的赋初值：数值型short，int，long等为0，bool为FALSE，指针为NULL； 将main函数的参数，argc，argv等传递给main函数，然后才真正运行main函数。 graph TB A(栈指针)-->B(初始化data段内容); B-->C(未初始化部分赋初值); C-->D(传递参数到Main); Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 12:29:58 "},"2-高级/2.8-模板/2.8.1-模板类和类模板.html":{"url":"2-高级/2.8-模板/2.8.1-模板类和类模板.html","title":"2.8.1-模板类和类模板","keywords":"","body":"类模板和模板类 类模板 ：通过模板实现的通用类，本质是个模板。 模板类：模板类是类模板实例化后的一个产物,就是传入泛型之后最终生成的类。本质是个类 例如： 类模板： template class 类名{ 类成员声明 }; 模板类： //有一个类模板 template class ClassA{ T getNum(); }; ClassA A;//已经实例化了，确定泛型参数为int 生成的类就是下面的 //这个就是生成的模板类 class ClassA{ int getNum(); }; Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 11:05:30 "},"2-高级/2.8-模板/2.8.2-模板函数和模板的特化.html":{"url":"2-高级/2.8-模板/2.8.2-模板函数和模板的特化.html","title":"2.8.2-模板函数和模板的特化","keywords":"","body":"模板函数和模板类的特例化 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 16:56:20 "},"2-高级/2.9-c++异常机制/":{"url":"2-高级/2.9-c++异常机制/","title":"2.9-c++异常机制","keywords":"","body":"纯虚函数 定义纯虚函数是为了实现一个接口，起到规范的作用，想要继承这个类就必须覆盖该函数。 实现方式是在虚函数声明的结尾加上= 0即可。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 13:30:20 "},"3-网络/":{"url":"3-网络/","title":"3-网络","keywords":"","body":"常见的网络知识 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-27 23:03:20 "},"3-网络/3.1-TCP和UDP/":{"url":"3-网络/3.1-TCP和UDP/","title":"3.1-TCP和UDP","keywords":"","body":"1.2 PDF简介1.7特性 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-26 02:37:02 "},"3-网络/3.1-TCP和UDP/3.1.1-TCP三次握手.html":{"url":"3-网络/3.1-TCP和UDP/3.1.1-TCP三次握手.html","title":"3.1.1-TCP三次握手","keywords":"","body":"TCP的三次握手 TCP开始传输时 需要建立连接，建立连接过程中会进行三次数据传输。 目的 确认传输双方: 发送信息能力 接受信息能力 过程 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 11:53:08 "},"3-网络/3.1-TCP和UDP/3.1.2-TCP四次挥手.html":{"url":"3-网络/3.1-TCP和UDP/3.1.2-TCP四次挥手.html","title":"3.1.2-TCP四次挥手","keywords":"","body":"TCP四次挥手 TCP结束传输时 需要断开连接，断开连接过程中会进行四次数据传输。 目的 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 11:53:16 "},"3-网络/3.2-socket/":{"url":"3-网络/3.2-socket/","title":"3.2-socket","keywords":"","body":"socket简介 套接字协议 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-27 23:02:54 "},"3-网络/3.2-socket/3.2.1-socket组成.html":{"url":"3-网络/3.2-socket/3.2.1-socket组成.html","title":"3.2.1-socket组成","keywords":"","body":"socket组成 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-27 23:03:02 "},"4-多线程/":{"url":"4-多线程/","title":"4-多线程","keywords":"","body":"1.介绍 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-26 02:37:02 "},"4-多线程/4.1-线程/":{"url":"4-多线程/4.1-线程/","title":"4.1-线程","keywords":"","body":"线程 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-27 23:10:10 "},"5-算法/":{"url":"5-算法/","title":"5-算法","keywords":"","body":"主要以Leetcode题目为主 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 01:12:58 "},"5-算法/5-15-并查集/":{"url":"5-算法/5-15-并查集/","title":"5-15-并查集","keywords":"","body":"1.介绍 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-26 02:37:02 "},"5-算法/5.1-数组/":{"url":"5-算法/5.1-数组/","title":"5.1-数组","keywords":"","body":"1.2 PDF简介1.7特性 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-26 02:37:02 "},"5-算法/5.1-数组/5.1.1_370.html":{"url":"5-算法/5.1-数组/5.1.1_370.html","title":"5.1.1_370","keywords":"","body":"Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-26 02:37:02 "},"5-算法/5.1-数组/5.1.1_531.html":{"url":"5-算法/5.1-数组/5.1.1_531.html","title":"5.1.1_531","keywords":"","body":"Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-26 02:37:02 "},"5-算法/5.10-深搜/":{"url":"5-算法/5.10-深搜/","title":"5.10-深搜","keywords":"","body":"1.介绍 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-26 02:37:02 "},"5-算法/5.11-广搜/":{"url":"5-算法/5.11-广搜/","title":"5.11-广搜","keywords":"","body":"1.介绍 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-26 02:37:02 "},"5-算法/5.12-贪心/":{"url":"5-算法/5.12-贪心/","title":"5.12-贪心","keywords":"","body":"1.介绍 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-26 02:37:02 "},"5-算法/5.13-动态规划/":{"url":"5-算法/5.13-动态规划/","title":"5.13-动态规划","keywords":"","body":"1.介绍 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-26 02:37:02 "},"5-算法/5.13-动态规划/5.13.1-651.html":{"url":"5-算法/5.13-动态规划/5.13.1-651.html","title":"5.13.1-651","keywords":"","body":"Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-26 02:37:02 "},"5-算法/5.13-动态规划/5.13.2-750.html":{"url":"5-算法/5.13-动态规划/5.13.2-750.html","title":"5.13.2-750","keywords":"","body":"Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-26 02:37:02 "},"5-算法/5.13-动态规划/5.13.3-1055.html":{"url":"5-算法/5.13-动态规划/5.13.3-1055.html","title":"5.13.3-1055","keywords":"","body":"Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-26 02:37:02 "},"5-算法/5.14-双指针/":{"url":"5-算法/5.14-双指针/","title":"5.14-双指针","keywords":"","body":"1.介绍 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-26 02:37:02 "},"5-算法/5.16-滑动窗口/":{"url":"5-算法/5.16-滑动窗口/","title":"5.16-滑动窗口","keywords":"","body":"1.介绍 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-26 02:37:02 "},"5-算法/5.2-字符串/":{"url":"5-算法/5.2-字符串/","title":"5.2-字符串","keywords":"","body":"1.介绍 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-26 02:37:02 "},"5-算法/5.2-字符串/5.2.1-536.html":{"url":"5-算法/5.2-字符串/5.2.1-536.html","title":"5.2.1-536","keywords":"","body":"Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-26 02:37:02 "},"5-算法/5.2-字符串/5.2.2-544.html":{"url":"5-算法/5.2-字符串/5.2.2-544.html","title":"5.2.2-544","keywords":"","body":"Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-26 02:37:02 "},"5-算法/5.3-递归/":{"url":"5-算法/5.3-递归/","title":"5.3-递归","keywords":"","body":"1.介绍 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-26 02:37:02 "},"5-算法/5.4-栈/":{"url":"5-算法/5.4-栈/","title":"5.4-栈","keywords":"","body":"1.介绍 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-26 02:37:02 "},"5-算法/5.5-链表/":{"url":"5-算法/5.5-链表/","title":"5.5-链表","keywords":"","body":"1.介绍 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-26 02:37:02 "},"5-算法/5.6-二分查找/":{"url":"5-算法/5.6-二分查找/","title":"5.6-二分查找","keywords":"","body":"1.介绍 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-26 02:37:02 "},"5-算法/5.7-树/":{"url":"5-算法/5.7-树/","title":"5.7-树","keywords":"","body":"1.介绍 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-26 02:37:02 "},"5-算法/5.8-二叉树/":{"url":"5-算法/5.8-二叉树/","title":"5.8-二叉树","keywords":"","body":"1.介绍 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-26 02:37:02 "},"5-算法/5.9-哈希表/":{"url":"5-算法/5.9-哈希表/","title":"5.9-哈希表","keywords":"","body":"1.介绍 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-26 02:37:02 "},"6-数据库/":{"url":"6-数据库/","title":"6-数据库","keywords":"","body":"Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 11:20:24 "},"7-数据结构/":{"url":"7-数据结构/","title":"7-数据结构","keywords":"","body":"Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 11:20:02 "},"8-操作系统/":{"url":"8-操作系统/","title":"8-操作系统","keywords":"","body":"Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 11:20:10 "},"9-计算机组成原理/":{"url":"9-计算机组成原理/","title":"9-计算机组成原理","keywords":"","body":"Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 11:20:18 "},"建议/":{"url":"建议/","title":"建议","keywords":"","body":"Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 11:25:10 "},"建议/新到岗位的建议.html":{"url":"建议/新到岗位的建议.html","title":"新到岗位的建议","keywords":"","body":"新到岗位的建议 像刚实习，或者刚换工作的同学最好： 1.刚到新岗位，多沟通，不要闷声干。 2.尽快熟悉，对自己明确的工作安排。 3.积极主动，不懂就问，和同事保持良好关系。 4.多表现自己，但不要喧宾夺主，注意不要过度炫耀。 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 12:58:58 "},"建议/程序员需要掌握的几种能力.html":{"url":"建议/程序员需要掌握的几种能力.html","title":"程序员需要掌握的几种能力","keywords":"","body":"程序员需要掌握的几种能力 1.解决问题能力 2.数学思维 3.专业能力 4.基本的编程逻辑思维 Copyright © ershouche-FE 2019 all right reserved，powered by Gitbook文件修订时间： 2022-02-28 12:57:38 "}}